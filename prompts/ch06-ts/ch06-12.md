> **Prompt**: Please explain excess property checks in TypeScript and why object literals are treated differently from variables.

In TypeScript, **Excess Property Checks** act as a specialized safety net that triggers only when you create a "fresh" object literal.

If you try to assign an object literal to a type, and that literal contains properties that aren't defined in the type, TypeScript will flag it as an errorâ€”even if the required properties are all present.

---

## 1. The "Freshness" Rule

TypeScript treats **Object Literals** (objects created on the spot) differently than **Existing Variables**.

### Scenario A: The Object Literal (Strict)

When you pass a literal directly, TypeScript assumes you might have made a typo or misunderstood the interface. It applies an "Exact Match" mentality.

```typescript
interface User {
  name: string;
}

// ERROR: 'age' does not exist in type 'User'
const person: User = {
  name: "Alice",
  age: 30 
};

```

### Scenario B: The Variable Reference (Loose)

If you assign that same object to a variable first, TypeScript uses **Structural Typing**. It only cares that the "minimum requirements" are met.

```typescript
const intermediate = { name: "Alice", age: 30 };

// SUCCESS: No error!
const person: User = intermediate; 

```

---

## 2. Why the different treatment?

It seems inconsistent, but there is a very practical reason for this distinction: **Catching Typos.**

### Why literals are strict:

If you are defining an object literal, you are explicitly trying to match a shape. If you add `email_adress` (a typo) instead of `email_address`, and TypeScript ignored the extra property, you would have a silent bug. TypeScript assumes that if you're providing a literal, you shouldn't be giving it "junk" data it didn't ask for.

### Why variables are loose:

In JavaScript, it is very common to have a large object (like a row from a database) and pass it into a function that only needs a small piece of it (like just the `name`).
If TypeScript were strict with variables, you would be forced to manually strip out extra properties every time you passed an object to a function, which would be incredibly tedious.

---

## 3. How to "Bypass" Excess Property Checks

If you intentionally want to allow extra properties in a literal, you have three main options:

* **Option 1: Use a variable.** As shown above, assigning to an intermediate variable "widens" the type.
* **Option 2: Use an Index Signature.** Tell the interface that extra properties are allowed.
```typescript
interface User {
  name: string;
  [key: string]: any; // Allows any other properties
}

```


* **Option 3: Type Assertion.** Use `as User`, but be careful, as this disables other safety checks too.

---

## 4. Summary Table

| Context | Checking Style | Purpose |
| --- | --- | --- |
| **Object Literal** | **Strict** (Excess Property Check) | Catches typos and prevents "stray" data during assignment. |
| **Variable Reference** | **Structural** (Minimum Match) | Allows flexibility and "Subtyping" (passing a large object where a small one is needed). |

---

### A Common "Gotcha"

This also applies to function arguments!

```typescript
function printName(user: { name: string }) {
  console.log(user.name);
}

// ERROR (Literal)
printName({ name: "Bob", age: 25 }); 

// SUCCESS (Variable)
const bob = { name: "Bob", age: 25 };
printName(bob); 

```
