> **Prompt**: How do professional teams gradually introduce TypeScript into an existing JavaScript codebase?

Professional teams rarely do a "big bang" rewrite because it’s too risky and halts feature development. Instead, they use a **strangler pattern**—gradually wrapping and replacing JavaScript until the TypeScript footprint covers the whole app.

Here is the standard industry playbook for a phased rollout:

---

## Phase 1: Infrastructure & "Loose" Integration

The goal here is to get the tools running without breaking the build or forcing developers to fix 1,000 errors at once.

* **Configure `tsconfig.json`:** Set `allowJs: true` (to allow JS and TS to coexist) and `noImplicitAny: false` (to keep the compiler from being too "loud" initially).
* **Establish a Build Pipeline:** Update the CI/CD pipeline so that it can compile both `.js` and `.ts` files using tools like **esbuild**, **SWC**, or **Babel**.
* **Install Community Types:** Add type definitions for third-party libraries using `@types` (e.g., `npm install @types/lodash`).

## Phase 2: The "Outside-In" Approach

Teams start by typing the data that flows **into** and **out of** the application.

* **Type the API Layer:** Define interfaces for your JSON responses. This provides immediate value to everyone by documenting what the data actually looks like.
* **Shared Constants/Utils:** Convert small, low-dependency utility files to `.ts`. These are "easy wins" with low risk.
* **JSDoc for Legacy Code:** Instead of converting complex files, add JSDoc comments. TypeScript reads these, giving you "Type Safety Lite" without changing the file extension.

## Phase 3: The "New Code" Mandate

Once the foundation is set, a new rule is established: **All new features must be written in TypeScript.**

* **The Conversion Rule:** If you have to touch an old `.js` file to fix a bug or add a small feature, you are encouraged (or required) to rename it to `.ts` and add types. This is often called the "Boy Scout Rule"—leave the code cleaner than you found it.

## Phase 4: Tightening the Screws

Once the majority of the codebase is `.ts`, teams begin to turn up the "strictness" to catch the bugs that Phase 1 ignored.

* **Enable `strict: true`:** This is the ultimate goal. It forces explicit handling of `null`, `undefined`, and `any`.
* **Ban `any`:** Teams often use ESLint rules (like `@typescript-eslint/no-explicit-any`) to prevent developers from "cheating" the type system.

---

### Strategy Comparison

| Feature | The "Loose" Start | The "Strict" Finish |
| --- | --- | --- |
| **File Extensions** | Mix of `.js` and `.ts` | 100% `.ts` or `.tsx` |
| **Type Accuracy** | Lots of `any` and `// @ts-ignore` | No `any`; specific Interfaces |
| **Compiler Rules** | `strict: false` | `strict: true` |
| **CI/CD** | "Warnings" only | Build fails on type errors |

---

### A Common Team Workflow

1. **Rename** `component.js` to `component.ts`.
2. **Fix** the immediate red squiggles (imports/exports).
3. **Use `any**` temporarily just to get the build passing.
4. **Refine** the `any` types into specific interfaces over the next few commits.

