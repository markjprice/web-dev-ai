> **Prompt**: What are readonly properties in TypeScript, and how do they help prevent bugs?

In TypeScript, `readonly` is a modifier that prevents a property from being reassigned after it has been initialized. It is essentially the "immutable" version of an object property.

While `const` prevents you from reassigning a **variable**, `readonly` prevents you from reassigning a **member** of an object or class.

---

## 1. How to Use `readonly`

You can apply `readonly` to interfaces, type aliases, or classes.

### In Interfaces and Types

```typescript
interface Configuration {
  readonly apiKey: string;
  readonly endpoint: string;
}

const config: Configuration = {
  apiKey: "12345",
  endpoint: "https://api.example.com"
};

config.apiKey = "67890"; // ERROR: Cannot assign to 'apiKey' because it is a read-only property.

```

### In Classes

In classes, you can initialize a `readonly` property either at the declaration or inside the `constructor`.

```typescript
class User {
  readonly id: number;

  constructor(id: number) {
    this.id = id; // This is allowed
  }

  updateId() {
    this.id = 99; // ERROR: Cannot assign to 'id' outside of the constructor.
  }
}

```

---

## 2. How it Prevents Bugs

The `readonly` modifier acts as "documentation that enforces itself." It helps prevent several common logic errors:

* **Accidental State Mutation:** In complex apps (especially with React or Redux), mutating state directly instead of returning a new object causes bugs where the UI doesn't update. `readonly` forces you to follow immutable patterns.
* **Protecting Global Constants:** If you have a configuration object used by 50 different files, `readonly` ensures that a junior developer (or a buggy utility function) doesn't accidentally overwrite the `API_URL` mid-execution.
* **Intentional Design:** It signals to other developers that a value is an **identity** (like a `userID`) rather than a **state** (like `isLoggedIn`).

---

## 3. The "Gotcha": It is not Deeply Immutable

A common mistake is assuming `readonly` protects everything inside an object. It only protects the **immediate property** it is attached to.

```typescript
interface Team {
  readonly manager: {
    name: string;
  };
}

const myTeam: Team = { manager: { name: "Sarah" } };

myTeam.manager = { name: "Bob" }; // ERROR: Property is readonly.
myTeam.manager.name = "Bob";     // SUCCESS: The 'name' property inside the object is NOT readonly.

```

To make an entire object deeply immutable, you would use the `Readonly<T>` utility type:

```typescript
const fullyLocked: Readonly<Team> = { ... };

```

---

## 4. Readonly Arrays

TypeScript also provides a specific type for arrays that should not be modified (no `.push()`, `.pop()`, or index assignment).

```typescript
const scores: readonly number[] = [90, 85, 70];
scores.push(100); // ERROR: Property 'push' does not exist on type 'readonly number[]'.

```

---

## Summary Table

| Feature | `const` | `readonly` |
| --- | --- | --- |
| **Applies to** | Variables | Object properties / Class members |
| **Check Time** | Runtime & Compile-time | **Compile-time only** |
| **Reassignment** | Blocked | Blocked |
| **Mutating internal props** | Allowed | Allowed (unless props are also `readonly`) |

---

### Pro-Tip: Readonly as a "Zero-Cost" Abstraction

Like most TypeScript features, `readonly` is stripped away during compilation. It adds **zero bytes** to your final JavaScript file and has **zero runtime overhead**, but it provides massive safety while you are writing the code.

# How to use the **`Readonly<T>`** and **`ReadonlyArray<T>`** utility types

TypeScript provides built-in "Utility Types" that act like functions for your types. Instead of manually adding `readonly` to every single line, these utilities allow you to transform entire structures instantly.

---

## 1. The `Readonly<T>` Utility

This utility takes an existing interface or type and maps over every property, adding the `readonly` modifier for you.

```typescript
interface User {
  id: number;
  username: string;
  email: string;
}

// All properties are now immutable
const activeUser: Readonly<User> = {
  id: 1,
  username: "jdoe",
  email: "john@example.com"
};

activeUser.username = "jane"; // ERROR: Cannot assign to 'username'

```

---

## 2. `ReadonlyArray<T>` (and the shorthand)

Standard arrays in JavaScript are highly mutable. If you pass an array to a function, that function could accidentally `.sort()` or `.push()` to it, changing the data for the rest of your app.

`ReadonlyArray` removes all "mutator" methods from the array’s autocomplete and compiler check.

```typescript
// Long form
const numbers: ReadonlyArray<number> = [1, 2, 3];

// Shorthand (most common)
const names: readonly string[] = ["Alice", "Bob"];

names.push("Charlie"); // ERROR: Property 'push' does not exist
names[0] = "Zoe";      // ERROR: Index signature only permits reading

```

---

## 3. Real-World Use Case: Functional Programming

In frameworks like **React**, you are often told: *"Never mutate state directly."* Using `Readonly` helps enforce this rule.

```typescript
interface State {
  count: number;
  tags: string[];
}

function reducer(state: Readonly<State>) {
  // TypeScript will stop you from doing this:
  state.count = state.count + 1; 
  
  // It forces you to return a NEW object:
  return {
    ...state,
    count: state.count + 1
  };
}

```

---

## 4. Summary of Immutable Utilities

| Utility | Syntax | Best Use Case |
| --- | --- | --- |
| **`Readonly<T>`** | `Readonly<User>` | Locking down a whole object (e.g., config or state). |
| **`readonly []`** | `readonly string[]` | Preventing functions from modifying an input list. |
| **`as const`** | `const obj = {...} as const` | Deeply locking a literal object and its nested values. |

---

### The "Deep" Alternative: `as const`

If you want a **deeply** readonly object (where even nested objects are locked) without writing complex types, you can use a "const assertion":

```typescript
const SETTINGS = {
  api: {
    port: 8080,
    url: "localhost"
  }
} as const;

SETTINGS.api.port = 9000; // ERROR: This is now deeply readonly!

```

# The difference between `Readonly<T>` and `as const`

While both **`Readonly<T>`** and **`as const`** aim for immutability, they operate at different levels of the TypeScript system. One is a **type transformation**, and the other is a **value assertion**.

---

## 1. `Readonly<T>` (The Surface Level)

`Readonly<T>` is a "Mapped Type." It takes an existing type and wraps its **top-level** properties in `readonly`.

* **Scope:** Shallow. It only affects the first layer of properties.
* **Source:** It works on **Types**.
* **Flexibility:** It’s great for function parameters where you want to ensure the function doesn't mutate the object you pass in.

```typescript
interface Data {
  meta: { id: number };
  tags: string[];
}

const item: Readonly<Data> = {
  meta: { id: 1 },
  tags: ["new"]
};

item.meta = { id: 2 }; // ERROR (Top level is locked)
item.meta.id = 2;      // SUCCESS (Nested level is still mutable)

```

---

## 2. `as const` (The Deep Freeze)

Known as a **Const Assertion**, this tells TypeScript to treat every single part of an object literal as a literal value rather than a general type (like `string` or `number`).

* **Scope:** Deep. It recursively applies `readonly` to every nested property and array.
* **Source:** It works on **Values** (object literals).
* **Specifics:** It converts properties to their literal values (e.g., instead of `string`, the type becomes exactly `"localhost"`).

```typescript
const CONFIG = {
  api: {
    port: 8080,
    url: "localhost"
  },
  codes: [200, 404]
} as const;

CONFIG.api.port = 9000; // ERROR (Deeply locked)
CONFIG.codes.push(500); // ERROR (Array is now a ReadonlyTuple)

```

---

## 3. Key Differences at a Glance

| Feature | `Readonly<T>` | `as const` |
| --- | --- | --- |
| **Depth** | **Shallow** (First level only) | **Deep** (All nested levels) |
| **Application** | Used on **Types** | Used on **Values/Literals** |
| **Type Widening** | Keeps types general (`string`) | Narrowed to literals (`"v1"`) |
| **Arrays** | Remains a standard array | Becomes a **Readonly Tuple** |

---

## 4. When to use which?

* **Use `Readonly<T>**` when you have an existing object (like a user from a database) and you want to pass it to a function while guaranteeing the function won't change its main properties.
* **Use `as const**` for **Configuration** and **Constants**. If you are defining a list of error codes, a routing map, or a theme object that should never change at any level, `as const` is the gold standard.

### Pro Tip: The "Literal" Bonus

A hidden benefit of `as const` is that it makes your types incredibly specific.

```typescript
const colors = ["red", "green"] as const;
type Color = typeof colors[number]; // Type is exactly: "red" | "green"

```

Without `as const`, the `Color` type would just be `string`.
