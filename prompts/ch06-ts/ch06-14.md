> **Prompt**: Please explain union types and intersection types in TypeScript with simple, real-world examples.

In TypeScript, you can think of Union and Intersection types as logical operators for your data. One is about **flexibility** (OR), and the other is about **combination** (AND).

---

## 1. Union Types (`|`)

A Union type says a value can be **one of several** types. It is the "OR" of the type world.

### Real-World Example: A Notification System

Imagine you are building a function that displays a message. The status could be a simple string, or a specific numeric code from a server.

```typescript
type Status = string | number;

function printStatus(code: Status) {
  console.log(`System status: ${code}`);
}

printStatus("Success"); // Valid
printStatus(200);       // Valid
printStatus(true);      // ERROR: boolean is not string | number

```

### The "Narrowing" Requirement

When you use a Union, TypeScript only lets you use properties that exist on **all** members of the union until you "narrow" it down.

```typescript
function formatStatus(code: Status) {
  if (typeof code === "number") {
    return code.toFixed(2); // Valid because code is definitely a number here
  }
  return code.toUpperCase(); // Valid because code is definitely a string here
}

```

---

## 2. Intersection Types (`&`)

An Intersection type combines multiple types into one. The new type has **all the features** of every member. It is the "AND" of the type world.

### Real-World Example: User Permissions

Imagine you have a basic `User` type and a separate `Permissions` type. An `Admin` is someone who has both.

```typescript
interface User {
  name: string;
  email: string;
}

interface Permissions {
  canDelete: boolean;
  adminLevel: number;
}

// An Admin IS a User AND has Permissions
type Admin = User & Permissions;

const superuser: Admin = {
  name: "Alice",
  email: "alice@company.com",
  canDelete: true,
  adminLevel: 1
};

```

---

## 3. Quick Comparison Table

| Feature | Union (`|`) | Intersection (`&`) |
| :--- | :--- | :--- |
| **Logic** | "Either A or B" | "Both A and B" |
| **Use Case** | Allowing multiple input formats. | Merging different models/features. |
| **Analogy** | A light switch (On or Off). | A Swiss Army Knife (Blade + Screwdriver). |
| **Member Access** | Only shared properties (until narrowed). | All properties from all members. |

---

## 4. Why use them together?

In professional code, these are often used in tandem to create "Discriminated Unions." This is where you have a list of objects (Union) that each have a shared property used to identify which specific object you are looking at.

```typescript
type APIResponse = 
  | { status: "success"; data: string[] }
  | { status: "error"; message: string };

function handleResponse(res: APIResponse) {
  if (res.status === "success") {
    console.log(res.data); // TS knows 'data' exists here
  } else {
    console.log(res.message); // TS knows 'message' exists here
  }
}

```

# How to use **Type Aliases** to make these Union and Intersection types more reusable

Using **Type Aliases** to manage Unions and Intersections is exactly how professional codebases stay readable. If you define these "recipes" once, you can reuse them across your entire app, from your API layer to your UI components.

---

## 1. Reusable Intersection "Mixins"

Instead of repeating properties like `id`, `createdAt`, or `updatedAt` on every interface, you can create "mixins" and intersect them where needed.

```typescript
type Timestamped = {
  createdAt: string;
  updatedAt: string;
};

type User = {
  id: string;
  username: string;
} & Timestamped; // Merges local properties with Timestamps

type Product = {
  id: string;
  price: number;
} & Timestamped;

```

---

## 2. Reusable Union "Registry"

Type aliases are perfect for defining a "set of possibilities." This is much cleaner than passing raw unions into every function.

```typescript
// Define the possibilities once
type NetworkState = "idle" | "loading" | "success" | "error";

// Reuse them everywhere
function updateIcon(state: NetworkState) { /* ... */ }
function logAnalytic(state: NetworkState) { /* ... */ }

```

---

## 3. The Power Move: Discriminated Unions

This is the most common pattern in production. You combine **Union** and **Intersection** logic to create a "smart" list of objects. By adding a common `kind` or `type` property, you make the union extremely easy to handle in `if` or `switch` statements.

```typescript
interface TextMessage {
  type: "text"; // The "Discriminant"
  content: string;
}

interface ImageMessage {
  type: "image"; // The "Discriminant"
  url: string;
  size: number;
}

// Create the Union
type Message = TextMessage | ImageMessage;

function renderMessage(msg: Message) {
  // TypeScript will only suggest 'type' initially
  switch (msg.type) {
    case "text":
      // Because the type is "text", TS knows 'content' exists
      return msg.content;
    case "image":
      // Because the type is "image", TS knows 'url' exists
      return msg.url;
  }
}

```

---

### Why this is better than raw interfaces

* **Scalability:** If you need to add a `VoiceMessage`, you just add it to the `Message` union.
* **Safety:** If you accidentally try to access `msg.url` inside the `text` case, TypeScript will stop you immediately.
* **Consistency:** All developers on the team use the same "vocabulary" (`Message`, `NetworkState`) rather than making up their own unions on the fly.

---

### Summary Table

| Technique | Goal | Syntax |
| --- | --- | --- |
| **Mixin Intersection** | Avoid repeating common properties. | `type A = B & C;` |
| **State Union** | Define a strict set of values. | `type A = "up" | "down";` |
| **Discriminated Union** | Create mutually exclusive object types. | `type A = {type: "x", ...} | {type: "y", ...}` |

---

# The **`Pick<T>`** and **`Omit<T>`** utility types

In modern TypeScript development, you often find yourself in a situation where you have a "Master Type" (like a User from a database) but only need a specific portion of it for a specific task (like a "Profile" page).

Instead of creating a brand new interface from scratch, you can use **`Pick`** and **`Omit`** to "transform" your existing types.

---

## 1. The `Pick<T, K>` Utility

`Pick` allows you to select a specific set of properties from an existing type. It’s like using a "Selective Filter."

**Best Use Case:** When you have a massive object but only need 2 or 3 fields for a simple UI component.

```typescript
interface Todo {
  id: string;
  title: string;
  description: string;
  completed: boolean;
  createdAt: number;
}

// We only want the title and completed status for a list view
type TodoPreview = Pick<Todo, "title" | "completed">;

const task: TodoPreview = {
  title: "Buy Milk",
  completed: false
};

```

---

## 2. The `Omit<T, K>` Utility

`Omit` does the opposite: it takes an existing type and removes the properties you list. It’s like using a "Deletion Filter."

**Best Use Case:** When you want almost everything from a type, except for a few sensitive or irrelevant fields (like an ID or a password).

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  passwordHash: string;
}

// Create a version of User that is safe to send to the frontend
type UserProfile = Omit<User, "id" | "passwordHash">;

const profile: UserProfile = {
  name: "John Doe",
  email: "john@example.com"
};

```

---

## 3. Comparison Table

| Utility | Logic | When to use? |
| --- | --- | --- |
| **`Pick`** | "I only want these." | When the new type is much **smaller** than the original. |
| **`Omit`** | "Give me everything except these." | When the new type is almost the **same size** as the original. |

---

## 4. Why Use These Instead of New Interfaces?

Using these utilities creates a **Single Source of Truth**.

If you update the `title` property in the original `Todo` interface (for example, renaming it to `heading`), both `Todo` and `TodoPreview` will update automatically. If you had manually created two separate interfaces, you would have to remember to update both, leading to desynchronized code and bugs.

---

## 5. Pro-Tip: The "Preview" Pattern

Professional teams often use these together with **Intersections** to create specialized types for forms.

```typescript
interface Product {
  id: string;
  name: string;
  price: number;
}

// A "Create" type usually needs everything EXCEPT the ID (since the DB generates it)
// AND it might need extra fields like a 'confirm' checkbox.
type CreateProductDTO = Omit<Product, "id"> & { confirmTerms: boolean };

```
