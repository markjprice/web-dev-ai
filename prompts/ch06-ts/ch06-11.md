> **Prompt**: What is the difference between an interface and a type alias in TypeScript, and when should I prefer one over the other?

This is one of the most common questions in TypeScript. For a long time, there were significant differences between the two, but in modern TypeScript, they have become very similar.

Think of it this way: **Interfaces** are primarily for defining the "shape" of objects, while **Type Aliases** are a general-purpose tool that can represent anything from an object to a simple list of strings.

---

## 1. Key Differences

### A. Declaration Merging (The Interface Speciality)

This is the biggest functional difference. If you define two interfaces with the same name in the same project, TypeScript will automatically merge them into one. Type aliases cannot do this; they will throw an error if you try to define the same name twice.

```typescript
interface User { name: string; }
interface User { age: number; }

// Result: User now has both name AND age
const person: User = { name: "Alice", age: 30 };

```

* **Why this matters:** This is how you "augment" existing libraries. If you want to add a property to the global `Window` object, you use an interface.

### B. Unions and Intersections

Type aliases are much more flexible when it comes to non-object types. You cannot use an interface to create a **Union** (an "OR" type) or a **Mapped Type**.

```typescript
// Only possible with Type Aliases
type Status = "success" | "error" | "loading"; 
type ID = string | number;

```

---

## 2. When to Use Which?

### Prefer `interface` when:

* **You are defining an object's structure:** Especially for components, models, or API responses.
* **You want to use `extends`:** Interfaces have a very clean syntax for inheritance (`interface Admin extends User`).
* **You are building a library:** This allows your users to use "Declaration Merging" to add their own custom properties to your types if they need to.

### Prefer `type` when:

* **You need a Union or Tuple:** If you need `string | number`, you must use a type.
* **You are using advanced features:** Like Mapped Types, Conditional Types, or Template Literal Types.
* **You want to alias a primitive:** For example, `type Pixel = number;`.
* **You prefer a more "functional" style:** Many developers find the assignment syntax (`type X = { ... }`) more intuitive.

---

## 3. Side-by-Side Comparison

| Feature | Interface | Type Alias |
| --- | --- | --- |
| **Object Shapes** | Yes | Yes |
| **Declaration Merging** | **Yes** | No |
| **Unions (`|`)** | No | **Yes** |
| **Tuples** | No | **Yes** |
| **Extending** | `extends` syntax | Intersection (`&`) syntax |

---

## Summary: The "Industry Standard" Advice

Most professional teams follow these two simple rules:

1. **Use `interface` for everything by default**, especially for objects and React component props.
2. **Switch to `type` only when you need it** (for Unions, Primitives, or complex logic).

Following this keeps your code consistent while leaving you the flexibility to use types when the "shape-only" nature of interfaces isn't enough.
