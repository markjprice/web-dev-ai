> **Prompt**: What is the never type, and in what situations does it appear in real code?

The `never` type is one of TypeScript's most unique features. While types like `string` or `number` describe what a value **is**, `never` describes a value that **can never exist**.

It represents the "empty set" in type theory. If a variable has the type `never`, you can't assign anything to it—not even `null` or `undefined`.

---

## 1. Where does it appear naturally?

You will usually see `never` pop up in three specific scenarios:

### A. Functions that Never Return

If a function contains an infinite loop or always throws an error, it doesn't return a value. It doesn't even return `void` (which technically returns `undefined`). It simply never finishes.

```typescript
function throwError(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {}
}

```

### B. Exhaustive Type Checking

This is the most "professional" use of `never`. It’s used to ensure you’ve handled every possible case in a `switch` or `if/else` block.

If you narrow a variable down until there are no possibilities left, TypeScript assigns it the type `never`.

```typescript
type Shape = "circle" | "square";

function getArea(shape: Shape) {
  switch (shape) {
    case "circle":
      return Math.PI * 5 ** 2;
    case "square":
      return 5 * 5;
    default:
      // If we handled all cases, 'shape' is now 'never'
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}

```

**Why this is useful:** If you later add `"triangle"` to the `Shape` type, TypeScript will throw an error at `_exhaustiveCheck` because `shape` would now be `"triangle"`, and you can't assign a `"triangle"` to a `never` type.

### C. Impossible Intersections

If you try to combine two types that contradict each other, TypeScript results in `never`.

```typescript
type StringAndNumber = string & number; // Result: never

```

A value cannot be both a string and a number at the exact same time, so this type is impossible to satisfy.

---

## 2. `never` vs. `any` vs. `void`

It’s easy to confuse these, but they serve completely different purposes:

| Type | Meaning | Can you assign a value to it? |
| --- | --- | --- |
| `any` | "I don't care what this is." | **Yes**, anything. |
| `void` | "This function returns nothing." | **Yes**, only `undefined`. |
| `never` | "This value is impossible." | **No**, absolutely nothing. |

---

## 3. Real-World Example: Filtering Types

In advanced TypeScript, `never` is used to "filter out" parts of a type. For example, if you want to create a type that takes an object and removes any properties that are strings:

```typescript
type NonStringProperties<T> = {
  [K in keyof T]: T[K] extends string ? never : T[K]
}[keyof T];

```

By assigning `never` to the string properties, they effectively disappear from the resulting type union.

---

### Why should you care?

Using `never` for **Exhaustive Checking** (Scenario B) is a superpower. It turns a "forgotten case" bug into a "compile-time error." It’s like having a safety net that tells you exactly where you forgot to update your logic when your data structures grow.

# How to use `never` to build a bulletproof `switch` statement

This pattern is known as **Exhaustive Type Checking**. It is the most robust way to ensure that as your application grows, your logic stays in sync with your data structures.

Here is a complete, real-world implementation using a `switch` statement:

```typescript
// 1. Define your union type
type UserRole = "admin" | "editor" | "viewer";

function getPermissions(role: UserRole) {
  switch (role) {
    case "admin":
      return ["create", "edit", "delete"];
    case "editor":
      return ["create", "edit"];
    case "viewer":
      return ["view"];

    default:
      /**
       * 2. The Exhaustive Check
       * If all cases above are handled, 'role' is narrowed to 'never'.
       * If you add a new role to the UserRole type (like "guest") 
       * but forget to add a 'case "guest":' here, TypeScript will
       * throw an error on the line below.
       */
      const _exhaustiveCheck: never = role;
      return _exhaustiveCheck;
  }
}

```

---

### Why this is a "Pro" Move

* **Future-Proofing:** Imagine six months from now, a teammate adds a `guest` role to the `UserRole` union at the top of the file. Without this check, the `getPermissions` function would silently hit the `default` case and potentially return `undefined` or a generic value, causing a bug.
* **Instant Feedback:** With this pattern, the moment they save the file after adding `guest`, TypeScript will highlight the `_exhaustiveCheck` line in red, saying: *Type 'string' is not assignable to type 'never'.*
* **Self-Documenting:** It tells other developers exactly why that `default` block exists—it’s a safety net, not just a fallback.

---

### Comparison: Standard vs. Exhaustive

| Approach | What happens if you miss a case? | Runtime Risk |
| --- | --- | --- |
| **Standard `switch**` | Returns `undefined` or a default value. | **High** (Logic errors/crashes) |
| **`never` Check** | **Compiler Error** (Build fails). | **Zero** (Must be fixed to run) |

---

### Final "Super" Pattern: The Utility Function

In many professional codebases, teams create a small utility to make this even cleaner:

```typescript
function assertNever(value: never): never {
  throw new Error(`Unhandled case: ${value}`);
}

// Usage in default block:
// default: return assertNever(role);

```

This gives you the best of both worlds: a **compile-time error** if you forget a case, and a **runtime crash** (with a helpful message) if someone somehow bypasses the type system.

# The `unknown` type, and why it is safer than `any`

In the world of TypeScript, `unknown` and `any` are often confused because they both represent a "mystery" value. However, they are philosophically opposites: **`any` is about convenience, while `unknown` is about caution.**

### 1. The Core Difference

* **`any` (The "Trust Me" Type):** You can do anything to an `any` variable. You can call it as a function, access properties on it, or multiply it by 10. TypeScript turns off all checking for that variable.
* **`unknown` (The "Prove It" Type):** You can do **nothing** to an `unknown` variable until you prove to TypeScript what it actually is.

---

### 2. Why `unknown` is safer than `any`

When you use `any`, you are telling the compiler: "Stop helping me." When you use `unknown`, the compiler says: "I won't let you touch this until you check its type first."

```typescript
let valueAny: any = "Hello World";
let valueUnknown: unknown = "Hello World";

// With 'any', this compiles but might crash at runtime
valueAny.toUpperCase(); 
valueAny.toFixed(); // No error! (But strings don't have .toFixed)

// With 'unknown', this fails to compile immediately
valueUnknown.toUpperCase(); // Error: 'valueUnknown' is of type 'unknown'.

```

---

### 3. How to "Unlock" an `unknown` Type

To use a value marked as `unknown`, you must perform a **Type Guard**. This forces you to write the runtime check that prevents crashes.

```typescript
function processData(input: unknown) {
  if (typeof input === "string") {
    // Inside this block, 'input' is narrowed to 'string'
    console.log(input.toUpperCase()); 
  } else if (typeof input === "number") {
    // Inside this block, 'input' is narrowed to 'number'
    console.log(input.toFixed(2));
  }
}

```

### 4. Real-World Situation: API Responses and JSON.parse

This is the most common place to use `unknown`. Historically, `JSON.parse` returns `any`, which is dangerous. Modern TypeScript teams often "cast" it to `unknown` to force themselves to validate it.

```typescript
const rawData = '{"name": "Alice"}';

// Dangerous: 'user' is 'any'
const userAny = JSON.parse(rawData); 
console.log(userAny.age.toString()); // Might crash!

// Safe: 'user' is 'unknown'
const userUnknown: unknown = JSON.parse(rawData);

// You are forced to check before using:
if (userUnknown && typeof userUnknown === 'object' && 'name' in userUnknown) {
  console.log("Success!");
}

```

---

### Summary Comparison

| Capability | `any` | `unknown` |
| --- | --- | --- |
| **Can assign anything to it?** | Yes | Yes |
| **Can access properties directly?** | Yes | **No** |
| **Requires Type Checking?** | No | **Yes** |
| **Safety Level** | Low (Same as JS) | High |

---

### Which one should you use?

Professional TypeScript code avoids `any` at almost all costs. If you truly don't know what a value is (like a response from an external API or a library), **always use `unknown**`. It forces you to be a better developer by handling all the "what if" scenarios.

