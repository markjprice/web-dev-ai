> **Prompt**: What does strict mode actually enable under the hood in TypeScript? What kinds of bugs TypeScript cannot catch, even with strict mode enabled?

Turning on `"strict": true` in your `tsconfig.json` isn't just one settingâ€”it is a "master switch" that activates a suite of eight specific flags. These flags change TypeScript from a helpful assistant into a rigorous enforcer.

---

## 1. What "Strict Mode" Enables

When you enable strict mode, you are primarily turning on these heavy hitters:

* **`strictNullChecks`**: By far the most impactful. Without this, `null` and `undefined` are valid values for *every* type (e.g., you could assign `null` to a `string`). With this on, you must explicitly handle them: `string | null`.
* **`noImplicitAny`**: Prevents the compiler from defaulting to `any` when it can't figure out a type. It forces you to be explicit, ensuring no "dark corners" of untyped code exist.
* **`strictFunctionTypes`**: Ensures that function parameters are checked more strictly. For example, it prevents you from passing a function that expects a specific "Sub-type" into a slot that provides a general "Base-type."
* **`strictPropertyInitialization`**: Forces you to ensure every class property is assigned a value in the constructor. This prevents "undefined" errors when calling class methods.
* **`useUnknownInCatchVariables`**: Changes the type of error objects in `catch` blocks from `any` to `unknown`, forcing you to check what the error is before interacting with it.

---

## 2. Bugs TypeScript *Still* Cannot Catch

Even with all strict flags set to the maximum, TypeScript has "blind spots." These are usually areas where the code is syntactically correct but logically flawed or influenced by external factors.

### A. Logical Errors

TypeScript ensures the **types** are correct, not the **logic**.

* **Example:** If you write a function to add numbers but accidentally use the subtraction operator:
```typescript
function add(a: number, b: number): number {
  return a - b; // Perfectly legal TypeScript, but a total logic bug.
}

```



### B. Out-of-Bounds Array Access

This is one of the most common runtime crashes in "safe" TypeScript. By default, TypeScript assumes that if you access an array index, an element will be there.

* **The Bug:** ```typescript
const names = ["Alice", "Bob"];
const person = names[10]; // TypeScript thinks 'person' is a string
console.log(person.toUpperCase()); // RUNTIME CRASH: Cannot read property of undefined
```
*(Note: There is a non-strict-mode flag called `noUncheckedIndexedAccess` that can help with this, but it is not enabled by default "strict" mode because it is very verbose.)*


```



### C. The "I Know Better" Escapes

If a developer uses certain syntax, they are manually disabling the safety net:

* **Type Assertions:** Using `as User` or `<User>data`.
* **Non-null Assertion:** Using the `!` operator (e.g., `user!.name`). This tells TS "I swear this isn't null," but if it is, the app crashes.

### D. Environmental Discrepancies

TypeScript doesn't know about your environment's limitations.

* **Example:** Using `Map.prototype.toSource()` which might work in one browser engine but not another.
* **Example:** Memory leaks or infinite loops.

### E. Data Mutation

TypeScript struggles to track how objects change over time across different function calls.

```typescript
let status: "loading" | "success" = "loading";

function checkStatus() {
  if (status === "loading") {
    doSomethingExternal(); // This function might change 'status' to 'success'
    // TypeScript still thinks 'status' is "loading" here
  }
}

```

---

### Summary: The Safety Gap

| Feature | TypeScript (Strict) | Reality (Runtime) |
| --- | --- | --- |
| **Null Safety** | High (prevents accidental nulls) | Depends on data integrity |
| **Array Safety** | Low (assumes index exists) | High risk of `undefined` |
| **Logic Safety** | Zero | Developer responsibility |
| **External Data** | Zero (unless validated) | Most common source of crashes |

