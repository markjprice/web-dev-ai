> **Prompt**: What are common mistakes beginners make when first using TypeScript?

Transitioning from JavaScript to TypeScript is like learning to drive with an instructor—it feels safer, but those constant "corrections" can be frustrating at first. Most beginners stumble because they try to treat TypeScript as a hindrance to bypass rather than a partner to collaborate with.

Here are the most common pitfalls and how to avoid them:

---

## 1. Overusing `any`

The biggest mistake is reaching for `any` the moment the compiler complains. Using `any` effectively turns TypeScript off for that variable, defeating the purpose of using the language in the first place.

* **The Mistake:** Using `any` to "make the red lines go away."
* **The Fix:** Use `unknown` if you truly don't know the type, or take five minutes to define a proper `interface`.

## 2. Thinking TypeScript Validates Data at Runtime

Beginners often assume that if they define a type for an API response, TypeScript will catch it if the server sends back something else.

* **The Mistake:** Expecting `const user: User = await response.json()` to throw an error if the data is malformed.
* **The Fix:** Remember that types are erased at runtime. Use a validation library like **Zod** or **Yup** to check the actual data coming in.

## 3. Not Enabling `strict` Mode

Many beginners start with a loose configuration to make the transition easier. This actually makes learning harder because the compiler won't warn you about `null` or `undefined` issues, which are the most common sources of bugs.

* **The Mistake:** Setting `"strict": false` in `tsconfig.json`.
* **The Fix:** Start with `"strict": true`. It’s stricter up front, but it prevents you from building a "tower of cards" that collapses later.

## 4. Misunderstanding "Excess Property Checks"

As we discussed earlier, beginners are often confused why passing an object directly causes an error, but passing it via a variable does not.

* **The Mistake:** Getting frustrated when an object literal with "extra" properties fails a check.
* **The Fix:** Understand that literals are checked for **exact** matches to catch typos, while variables are checked for **minimum** requirements.

## 5. Over-Typing Everything

In the beginning, it's tempting to explicitly type every single variable.

```typescript
const x: number = 5; // Unnecessary!

```

* **The Mistake:** Adding type annotations where TypeScript can already **infer** them.
* **The Fix:** Let TypeScript's **Inference** do the heavy lifting. Only add annotations when the compiler can't figure it out (like function parameters or empty arrays).

## 6. Confusion Between `interface` and `type`

Beginners often spend too much time worrying about which one to use.

* **The Mistake:** Paralyzed by the choice between the two.
* **The Fix:** Pick one and be consistent. The community standard is **interfaces for objects** and **types for unions/aliases**.

## 7. Forgetting that `null` and `undefined` are Different

In strict mode, `string | null` is not the same as `string | undefined`.

* **The Mistake:** Assuming an optional property (`name?: string`) can also be `null`.
* **The Fix:** If an API can return `null`, you must explicitly include it: `name: string | null`.

---

### Summary Checklist

| Mistake | Consequence | Professional Alternative |
| --- | --- | --- |
| **Using `any**` | Silent runtime crashes. | Use `unknown` or specific interfaces. |
| **Manual Casting (`as`)** | You lie to the compiler. | Use **Type Guards** to prove the type. |
| **Ignoring Errors** | Technical debt builds up. | Fix errors immediately; don't use `// @ts-ignore`. |
| **No Runtime Checks** | Corrupt data enters the app. | Use **Zod** for API/Form validation. |

---

# Setting up ESLint with TypeScript

Setting up **ESLint** alongside TypeScript is the "secret sauce" used by professional teams to automate code quality. While the TypeScript compiler checks if your code is *valid*, ESLint checks if your code is *good*.

It can catch things like the "overuse of `any`" or "forgotten `await`" before you even try to compile.

---

## 1. The Core Setup

To get started, you need to install the ESLint engine and the specific plugins that allow it to understand TypeScript.

```bash
npm install --save-dev eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin

```

## 2. The Configuration (`.eslintrc.json`)

Create a file named `.eslintrc.json` in your root directory. This config tells ESLint to use the TypeScript parser and enables the "Recommended" rule sets.

```json
{
  "parser": "@typescript-eslint/parser",
  "plugins": ["@typescript-eslint"],
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking"
  ],
  "parserOptions": {
    "project": "./tsconfig.json"
  },
  "rules": {
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/consistent-type-definitions": ["error", "interface"]
  }
}

```

---

## 3. Top 3 Rules for Beginners

These rules specifically target the mistakes we discussed earlier:

### A. `no-explicit-any`

This rule will highlight every time you type `any`.

* **Setting:** `"warn"` or `"error"`.
* **Benefit:** It forces you to think: "Is there a better way to type this?"

### B. `no-floating-promises`

A very common bug is forgetting to `await` an asynchronous API call.

* **Benefit:** ESLint will alert you if you call an `async` function without handling the result. This prevents "race conditions" where code runs in the wrong order.

### C. `@typescript-eslint/await-thenable`

Beginners often put `await` in front of functions that aren't actually asynchronous.

* **Benefit:** It keeps your code clean by removing unnecessary `await` keywords that don't do anything.

---

## 4. Integration with your Editor

To get the most out of this, you should install the **ESLint extension** for your editor (like VS Code).

* **The Experience:** As you type a mistake (like using `any`), a yellow or red underline appears immediately.
* **Auto-Fix:** Many ESLint rules come with an "Auto-fix" option. You can set your editor to "Fix on Save," which automatically cleans up your code formatting and simple type issues every time you hit save.

---

## Summary: The "Safety Stack"

| Tool | Role | Focus |
| --- | --- | --- |
| **TypeScript** | The Compiler | Are the types valid? |
| **ESLint** | The Linter | Is the code following best practices? |
| **Prettier** | The Formatter | Does the code look consistent (tabs vs spaces)? |

---

### Pro-Tip: The "Type-Aware" Rules

Note the `recommended-requiring-type-checking` line in the config. This allows ESLint to actually "ask" TypeScript about your variables. It’s slower than basic linting, but it’s the only way to catch deep logic bugs like "treating a Promise as a String."

