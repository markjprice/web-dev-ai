> **Prompt**: Please explain function overloads in TypeScript and show a realistic example where they improve clarity.

In JavaScript, you can write a function that accepts multiple types of arguments and returns different results based on those arguments. However, describing that behavior to TypeScript can be tricky.

**Function Overloads** allow you to provide multiple "signatures" for a single function. This tells TypeScript: "If the user calls it *this* way, the return will be *this*; but if they call it *that* way, the return will be *that*."

---

## 1. The Anatomy of an Overload

An overloaded function consists of two parts:

1. **Overload Signatures:** Multiple lines that define the allowed ways to call the function. These do not have a "body" (no `{}`).
2. **Implementation Signature:** The actual code of the function. This signature must be compatible with all the overloads above it.

---

## 2. A Realistic Example: The `Date` Formatter

Imagine you are building a utility to format dates. You want it to be flexible: it should accept either a **timestamp (number)** or a **Date object**.

### Without Overloads (The "Vague" Way)

If you use a union type, the return type becomes a bit "blurry," and you lose the specific connection between input and output.

```typescript
function format(input: Date | number): string | number {
  // logic...
}

const result = format(new Date()); // TypeScript thinks 'result' is string | number
// Now you have to use 'as string' or a type guard to use string methods.

```

### With Overloads (The "Clear" Way)

Overloads link the input type directly to the output type.

```typescript
// OVERLOAD SIGNATURES
function makeDate(timestamp: number): Date;
function makeDate(year: number, month: number, day: number): Date;

// IMPLEMENTATION SIGNATURE (The actual logic)
function makeDate(arg1: number, arg2?: number, arg3?: number): Date {
  if (arg2 !== undefined && arg3 !== undefined) {
    return new Date(arg1, arg2, arg3);
  }
  return new Date(arg1);
}

const d1 = makeDate(1609459200000); // TS knows this returns a Date
const d2 = makeDate(2026, 5, 10);    // TS knows this also returns a Date

```

---

## 3. Why This Improves Clarity

Overloads provide **Intellisense Documentation**. When a developer types `makeDate(`, their editor will actually show them that there are **2 distinct ways** to call the function.

* **Better Errors:** If someone tries to call `makeDate(2026, 5)`, TypeScript will throw an error because there is no 2-argument overload defined. Without overloads, it might allow it but crash at runtime.
* **No Casting:** You don't have to use `as string` or `as Date` when you get the result back. TypeScript "remembers" which overload was triggered.

---

## 4. Important Rules to Remember

* **The implementation is hidden:** The outside world only sees the overload signatures. You cannot call the function using the "Implementation Signature" unless it matches one of the overloads.
* **Order matters:** TypeScript tries to match overloads from **top to bottom**. Put your most specific signatures at the top.
* **Compatibility:** The implementation signature must be broad enough to handle every overload. Usually, this involves optional parameters (`?`) or union types (`|`).

---

### Comparison: Union Types vs. Overloads

| Feature | Union Types (`A | B`) | Function Overloads |
| :--- | :--- | :--- |
| **Complexity** | Simple to write. | Slightly more boilerplate. |
| **Accuracy** | Output type is a union of all possibilities. | Output type is specific to the input. |
| **Developer Experience** | Shows one complex signature. | Shows multiple clean "options." |

