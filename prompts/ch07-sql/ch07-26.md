> **Prompt**: Please compare single-column and composite indexes with realistic query patterns.

Choosing between several single-column indexes and one composite index is a common "fork in the road" during database optimization. The right choice depends entirely on the **order** of your query filters and the **selectivity** of your columns.

---

## 1. Single-Column Index

A single-column index tracks only one field. If you have indexes on `last_name` and `first_name` separately, the database has two independent "address books."

### Query Pattern: Simple Lookups

```sql
SELECT * FROM users WHERE last_name = 'Smith';

```

* **Performance:** Excellent. The engine jumps straight to the "S" section.
* **The Problem:** If you search for `WHERE last_name = 'Smith' AND first_name = 'John'`, the engine has to pick one index, find all the Smiths, and then manually scan through them to find the Johns. (Alternatively, it might try an "Index Merge," which is computationally expensive).

---

## 2. Composite Index (Multi-Column)

A composite index combines multiple columns into a single B-Tree structure. The order of columns in the index is critical because the data is sorted **lexicographically**â€”like a telephone book (Last Name first, then First Name).

### Query Pattern: Specific Multi-Filter

```sql
-- Index on (last_name, first_name)
SELECT * FROM users WHERE last_name = 'Smith' AND first_name = 'John';

```

* **Performance:** Optimal. The engine finds the "Smiths" and, because the index is already sorted by "John" within that group, it finds the exact row instantly.

---

## 3. The "Left-to-Right" Rule

The biggest trade-off with a composite index is that it is only useful if your query filters follow the index columns from left to right.

Imagine an index on `(Country, State, City)`.

| Query Pattern | Can it use the Index? | Why? |
| --- | --- | --- |
| `WHERE Country = 'USA'` | **Yes** | Uses the first part of the index. |
| `WHERE Country = 'USA' AND State = 'NY'` | **Yes** | Uses the first two parts. |
| `WHERE State = 'NY'` | **No** | It can't skip the "Country" level to get to the "State" level. |

---

## 4. Realistic Comparison: (Email, Status)

Let's look at a common pattern: finding a user's active orders.

### Scenario A: Two Single-Column Indexes

`INDEX(email)`, `INDEX(status)`

* **Query:** `WHERE email = 'user@example.com' AND status = 'pending'`
* **Behavior:** The engine uses the `email` index to find 50 orders for that user, then checks the `status` of each one manually. This is fast, but not perfectly efficient.

### Scenario B: One Composite Index

`INDEX(email, status)`

* **Query:** Same as above.
* **Behavior:** The engine finds the exact "Pending" row for that specific "Email" in one single "Seek" operation. This is the fastest possible path.

---

## Summary Trade-offs

| Feature | Single-Column | Composite Index |
| --- | --- | --- |
| **Flexibility** | High (works for any query on that column) | Low (order matters strictly) |
| **Storage** | Lower per index | Higher (stores multiple columns) |
| **Write Speed** | Faster (simpler updates) | Slower (more data to re-sort) |
| **Best For** | Ad-hoc queries on various fields | Frequent, specific multi-column filters |

### The "Selective" Tip

When creating a composite index, always put the **most selective** column (the one that narrows down the data the most) as the **first** column. This allows the engine to discard the largest amount of irrelevant data as quickly as possible.

