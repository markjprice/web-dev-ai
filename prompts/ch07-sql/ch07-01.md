> **Prompt**: What trade-offs do relational databases like SQLite and PostgreSQL make compared to document databases like MongoDB?

Choosing between a relational (SQL) and a document (NoSQL) database is rarely about which is "better" in a vacuum; it’s about where you want to spend your "complexity budget." Relational databases like **PostgreSQL** and **SQLite** prioritize consistency and structure, while document stores like **MongoDB** prioritize flexibility and horizontal growth.

Here is a breakdown of the primary trade-offs:

---

## 1. Schema Rigidity vs. Flexibility

In the relational world, you must define your "shape" before you can store any data.

* **Relational (PostgreSQL/SQLite):** Uses a **fixed schema**. If you want to add a "middle name" field to a million users, you must perform an `ALTER TABLE` operation. This ensures data integrity—you can’t accidentally save a string where an integer belongs.
* **Document (MongoDB):** Uses a **dynamic schema**. Data is stored in JSON-like documents. One "User" document might have five fields, and the next might have ten. This is ideal for rapid prototyping or when dealing with unpredictable data structures.

## 2. Relationships: Joins vs. Embedding

This is the most significant architectural trade-off regarding how data is accessed.

* **Relational (Normalization):** You break data into many small tables and use **Joins** to stitch them together.
* *Trade-off:* Efficient storage (no duplication) but higher computational cost at read-time for complex queries.


* **Document (Denormalization):** You often **embed** related data within a single document (e.g., placing all "Comments" inside a "Post" document).
* *Trade-off:* Extremely fast reads for that specific document, but data is often duplicated, making updates across the board more difficult.



## 3. ACID Compliance and Consistency

* **Relational:** Traditionally built to be **ACID compliant** (Atomicity, Consistency, Isolation, Durability) by default. This makes them the gold standard for financial systems where a "partial" transaction (money leaving one account but not hitting the other) is a catastrophe.
* **Document:** While MongoDB now supports multi-document ACID transactions, these databases were originally designed for **Eventual Consistency**. They prioritize availability; the data might take a few milliseconds to "settle" across all nodes in a cluster.

## 4. Scaling: Vertical vs. Horizontal

* **Vertical (PostgreSQL/SQLite):** You scale by "buying a bigger boat"—more RAM, more CPU. While PostgreSQL has sharding capabilities, it is inherently more complex to scale across multiple servers than NoSQL.
* **Horizontal (MongoDB):** Designed from day one to be **distributed**. You scale by "adding more boats" (sharding). It handles massive volumes of data across multiple cheap servers much more natively than traditional SQL.

---

### Comparison Summary

| Feature | Relational (PostgreSQL/SQLite) | Document (MongoDB) |
| --- | --- | --- |
| **Data Model** | Tables/Rows | Documents (JSON/BSON) |
| **Best For** | Complex joins & high integrity | Rapidly changing data & high volume |
| **Scaling** | Primarily Vertical | Primarily Horizontal |
| **Transactions** | Robust ACID by default | Tunable; excels at single-document |

