> **Prompt**: Please compare `COALESCE`, `NULLIF`, and `CASE` with real-world use cases.

In SQL, these three tools are your primary defenses against `NULL` logic errors. While they overlap in capability, they each have a distinct "personality" and use case.

---

## 1. COALESCE: The "Fall-Back" Specialist

`COALESCE(val1, val2, ... valN)` returns the first **non-null** value in its list. It is the most common way to provide "default" values.

### Real-World Use Case: User Notifications

Imagine a table where users can provide a mobile number, an email, or both. You want to know where to send an alert, prioritizing mobile.

```sql
SELECT 
  username, 
  COALESCE(mobile_number, email, 'No contact info provided') AS primary_contact
FROM users;

```

* **Why use it?** It keeps your code clean. Without it, you would need a messy, nested `IF` or `CASE` statement to check which fields are empty.
* **The Logic:** "Try A; if that’s missing, try B; if that’s missing, use this default string."

---

## 2. NULLIF: The "Divisor" Safeguard

`NULLIF(val1, val2)` returns `NULL` if the two values are **equal**; otherwise, it returns the first value.

### Real-World Use Case: Preventing "Division by Zero"

This is the "killer app" for `NULLIF`. In SQL, dividing by zero crashes your query. Dividing by `NULL` simply results in `NULL`, which is much safer for reports.

```sql
-- Without NULLIF: Crashes if current_year_sales is 0
-- With NULLIF: Returns NULL if sales are 0, avoiding the crash
SELECT 
  product_id,
  (current_year_sales / NULLIF(previous_year_sales, 0)) AS growth_ratio
FROM sales_data;

```

* **Why use it?** To "neutralize" specific values (like 0 or empty strings) that would otherwise break your math or logic.
* **The Logic:** "If this value is X, pretend it's unknown so it doesn't break anything."

---

## 3. CASE: The "Logical" Powerhouse

`CASE` is essentially an `if-then-else` statement for SQL. It is the most verbose but also the most flexible.

### Real-World Use Case: Business Categorization

Use `CASE` when your logic involves ranges or multiple columns that can't be solved by a simple "is it null?" check.

```sql
SELECT 
  order_id,
  total_price,
  CASE 
    WHEN total_price > 1000 THEN 'Platinum'
    WHEN total_price > 500 THEN 'Gold'
    WHEN total_price IS NULL THEN 'Uncalculated'
    ELSE 'Standard'
  END AS customer_tier
FROM orders;

```

* **Why use it?** When you need complex conditional logic, range checks (`> 100`), or multiple conditions combined with `AND`/`OR`.
* **The Logic:** "Evaluate these rules in order and stop at the first one that fits."

---

## Summary Comparison

| Function | Complexity | Primary Purpose | Best Shortcut |
| --- | --- | --- | --- |
| **COALESCE** | Low | Filling in missing data. | Replacing `NULL` with a default. |
| **NULLIF** | Low | Hiding specific values. | Preventing division by zero. |
| **CASE** | High | Categorizing or branching. | Complex "If-Then" business logic. |

### Pro-Tip: The "Power Combo"

You can actually nest these. For example, to find an average but avoid a division-by-zero error while ensuring the final result isn't `NULL`:

```sql
SELECT 
  COALESCE(SUM(score) / NULLIF(COUNT(score), 0), 0) as safe_avg 
FROM exam_results;

```
