> **Prompt**: Why does NULL behave differently from other values in comparisons and aggregates?

The reason `NULL` behaves so strangely is that it represents **missing information**, not a value. In the mathematical foundation of SQL (Three-Valued Logic), `NULL` is treated as **Unknown**.

Think of it this way:

* An empty string (`''`) is like an empty box—you know what’s inside (nothing).
* A `0` is like a box containing a zero.
* A `NULL` is a **missing box**. You cannot say if a missing box is equal to another missing box because you don't know what's in either one.

---

## 1. Why Comparisons Fail (`NULL` is Viral)

In standard binary logic, a statement is either `TRUE` or `FALSE`. In SQL, there is a third state: `UNKNOWN`.

When you compare anything to `NULL`, the result is `UNKNOWN`. Because SQL filters (like `WHERE`) only let through rows that are explicitly `TRUE`, `UNKNOWN` rows are discarded.

* **The "Equal" Problem:** `5 = NULL` results in `UNKNOWN`.
* **The "Not Equal" Problem:** `5 != NULL` also results in `UNKNOWN`.
* **The Identity Problem:** `NULL = NULL` is still `UNKNOWN`.

**The Exception:** The only operators that can handle this state are `IS NULL` and `IS NOT NULL`, which check the **metadata** of the row rather than the value itself.

---

## 2. Why Aggregates "Ignore" `NULL`

If `NULL` is "Unknown," then including it in a calculation would logically make the final result unknown. However, to make databases useful, the SQL standard decided that aggregate functions should **skip** them.

### Math Functions (`SUM`, `AVG`, `MIN`, `MAX`)

If you have three rows: `10, 20, NULL`:

* **The "Logical" Math:** .
* **The "SQL" Math:** .
The engine acts as if the row simply doesn't exist for that specific calculation.

### The `COUNT` Divergence

This is where the behavior gets truly inconsistent:

* `COUNT(*)`: Counts the **rows** (slots in the table). It doesn't care if a slot is "empty" (NULL), so it counts it.
* `COUNT(column)`: Counts the **values**. Since `NULL` is not a value, it ignores it.

---

## 3. The Performance Cost of `NULL`

Because `NULL` is a special state, it often requires extra work from the database engine:

1. **Storage:** Most databases store a "null bitmap" at the start of each row. This is a series of bits that tell the engine which columns in that specific row are null before it even tries to read the data.
2. **Indexing:** In many older database versions (and some modern ones), `NULL` values are not included in standard B-Tree indexes. This means a query like `WHERE column IS NULL` might force a slow full-table scan because the index simply doesn't track where the "missing" boxes are.

---

## Summary of `NULL` Behavior

| Operation | Result with `NULL` | Mental Model |
| --- | --- | --- |
| **`5 + NULL`** | `NULL` |  |
| **`'A' = NULL`** | `UNKNOWN` | Can't compare to a ghost |
| **`SUM()`** | Ignores it | "Treat it like it's not there" |
| **`COUNT(*)`** | Includes it | "There is a seat here, even if it's empty" |

### How to handle this safely

The safest way to bridge the gap between "Unknown" and "Known" is to use `COALESCE`. It forces the database to pick a side:
`SELECT AVG(COALESCE(bonus, 0)) FROM employees;` — This ensures the average is calculated against the entire staff, treating those with no bonus as  rather than simply ignoring them.

