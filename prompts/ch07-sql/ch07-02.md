> **Prompt**: How closely do modern databases actually follow the ISO SQL standard? Explain why SQL dialects diverged and why full portability is difficult in practice.

In theory, the ISO/IEC 9075 standard provides a blueprint for how SQL should work. In reality, no major database engine implements 100% of the standard, and even the parts they do implement often come with "flavor-specific" twists.

Think of the ISO standard as a **gentle suggestion** rather than a rigid law.

---

## The Reality of Compliance

The SQL standard is massive (thousands of pages) and broken into several parts (Framework, Foundation, CLI, etc.). Most modern relational databases like **PostgreSQL**, **MySQL**, and **SQL Server** strive for "Core" compliance, but divergence begins the moment you move beyond basic `SELECT`, `INSERT`, and `UPDATE` statements.

* **PostgreSQL:** Often cited as the most "standards-compliant" open-source database. It supports a vast majority of the required features but still has its own unique syntax for things like `DISTINCT ON` or its robust JSONB implementation.
* **SQLite:** Purposefully ignores parts of the standard to remain lightweight. For example, it historically lacked a `FOR EACH ROW` trigger syntax and has a unique "manifest typing" system rather than strict data types.
* **MySQL:** For years, it was notorious for "silent errors" and non-standard behavior (like allowing invalid dates), though modern versions (8.0+) have moved much closer to the ISO line.

---

## Why Dialects Diverged

The "Babel-like" divergence of SQL dialects wasn't an accident; it was a result of competition and technical necessity.

### 1. The "Feature Arms Race"

In the 80s and 90s, database vendors (Oracle, IBM, Microsoft) competed on performance and features. If a customer needed a specific window function or a way to handle hierarchical data before the ISO committee had even met to discuss it, the vendor would simply invent their own syntax. By the time the standard was updated, thousands of companies were already locked into the vendor's "non-standard" version.

### 2. Implementation Philosophy

Different databases are built for different goals:

* **PostgreSQL** focuses on extensibility and academic correctness.
* **SQLite** focuses on being a single-file, zero-config library.
* **Oracle** focuses on enterprise-scale legacy support.
These differing goals require different underlying architectures, which often make standard syntax difficult or inefficient to implement.

---

## Why Portability is a Myth

Software developers often dream of "database-agnostic" code, but full portability is rarely achieved because of these three friction points:

### The Syntax Gap

Even simple things vary. To limit the number of rows returned:

* **PostgreSQL/MySQL:** `LIMIT 10`
* **SQL Server:** `SELECT TOP 10`
* **ISO Standard:** `FETCH FIRST 10 ROWS ONLY`

### The "Leaky Abstraction" of Types

The standard defines types like `BOOLEAN` or `TIMESTAMP`, but implementation varies wildly. One database might treat a Boolean as a `T/F` value, while another (like SQLite) treats it as an integer `0` or `1`. Moving data between them often requires complex transformation scripts.

### Performance Optimization

To make a database fast, you have to use its "secret sauce." If you write purely standard-compliant SQL, you lose access to vendor-specific optimizations like PostgreSQL's **Partial Indexes** or SQL Server's **Columnstore Indexes**. If you want speed, you have to write code that only works on one platform.

---

## The Modern Solution: Tooling over Standards

Instead of relying on the ISO standard for portability, most modern teams use **Abstractions**:

* **ORMs (Object-Relational Mappers):** Tools like SQLAlchemy, Hibernate, or Prisma translate a single "language" into the specific dialect of your database.
* **Liquibase/Flyway:** These tools manage the "migration" scripts, handling the dialect differences so the developer doesn't have to manually write `ALTER TABLE` for three different engines.

