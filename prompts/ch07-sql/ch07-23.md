> **Prompt**: Please explain how a database chooses between a table scan and an index scan.

When you run a query, the **Query Optimizer** acts like a librarian deciding whether to walk through every single page of every book (Table Scan) or use the alphabetical index at the back (Index Scan).

Surprisingly, the "faster" choice isn't always the index. The decision is based on **Cost-Based Optimization**, where the engine calculates the estimated "price" of each path in terms of disk I/O and CPU cycles.

---

## 1. The Decision Factors

The engine looks at its **Statistics** (metadata it keeps about your data) to make the call:

### Selectivity and Cardinality

* **Selectivity:** How much of the table are you asking for? If you are asking for "All users where `ID = 502`," that is **highly selective**. The engine will almost certainly use an index.
* **Cardinality:** If you ask for "All users where `gender = 'F'`," and half the table matches, an index might actually be *slower*. This is because jumping back and forth between the index and the actual table data (the "Bookmark Lookup") creates "Random I/O," which is more expensive than just reading the whole file in one smooth "Sequential Scan."

### Table Size

If a table fits into a single page of memory (usually 8KB), a **Table Scan** is faster. It takes more effort for the engine to load the index, search it, and then go to the table than it does to just read the 10 rows in the table.

---

## 2. Types of Scans

### Full Table Scan (Sequential Scan)

The engine reads the entire table from beginning to end.

* **When it’s chosen:** The query lacks a `WHERE` clause, the column isn't indexed, or the engine expects to return more than ~5-10% of the total rows.

### Index Scan

The engine traverses the entire index tree.

* **When it’s chosen:** You are looking for a range of values (e.g., `WHERE price > 100`) and the index is "covering" (meaning the index itself contains all the data the `SELECT` clause needs).

### Index Seek (The "Gold Standard")

The engine uses the B-Tree structure to jump straight to a specific starting point.

* **When it’s chosen:** You are searching for a specific value on a primary key or a highly unique indexed column.

---

## 3. Why the Optimizer might "Ignore" your Index

Developers are often frustrated when they add an index but the database still does a Table Scan. This usually happens because:

1. **Functions on Columns:** If you write `WHERE YEAR(created_at) = 2026`, the engine cannot use a standard index on `created_at`. It has to calculate the year for every single row, forcing a **Table Scan**.
2. **Type Mismatch:** If `user_id` is a string but you query `WHERE user_id = 123` (an integer), the engine may have to convert every row to a number to compare them, bypassing the index.
3. **The "Tipping Point":** As mentioned, if the engine estimates that your query will return a large chunk of the table, it "tips" over into a Table Scan because sequential reading is more efficient for high volumes of data.

---

## Summary Comparison

| Path | Best For | Typical I/O Pattern |
| --- | --- | --- |
| **Table Scan** | Small tables or non-selective queries | **Sequential** (Fast for large data) |
| **Index Scan** | Narrow ranges or "Covering" queries | **Sequential/Random mix** |
| **Index Seek** | Finding specific rows (ID lookup) | **Random** (Fast for small data) |

### How to see the choice

In any SQL tool, you can prefix your query with `EXPLAIN` (Postgres/MySQL) or `EXPLAIN QUERY PLAN` (SQLite). It will show you exactly which path it chose and its estimated "cost."

```sql
EXPLAIN SELECT * FROM users WHERE email = 'gemini@google.com';
-- Look for "Index Scan" or "Index Seek" in the output

```
