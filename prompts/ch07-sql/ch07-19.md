> **Prompt**: How do SQLite and PostgreSQL differ in transaction and locking behavior?

While both databases are ACID-compliant, they handle concurrent access—multiple people reading and writing at the same time—using completely different philosophies. **PostgreSQL** is built for a "crowded room" of users, while **SQLite** is built for a "private desk."

---

## 1. Locking Granularity

The biggest difference is "how much" of the database gets locked when someone wants to make a change.

* **SQLite (Database-Level):** Traditionally, SQLite locks the **entire database file**. If one user is writing to a "Comments" table, every other user is blocked from writing to the "Users" or "Posts" table until the first person finishes.
* **PostgreSQL (Row-Level):** Postgres uses sophisticated **row-level locking**. Multiple users can write to the same table simultaneously, as long as they aren't trying to change the exact same row.

---

## 2. Multi-Version Concurrency Control (MVCC)

PostgreSQL uses **MVCC**, a system that allows readers to never block writers, and writers to never block readers.

* **How Postgres does it:** When you update a row, Postgres doesn't overwrite the old data immediately. It creates a new "version" of that row. Readers keep looking at the old version until the writer commits the transaction. This means your "Select" queries are never slowed down by someone else's "Update" queries.
* **How SQLite does it (Journaling vs. WAL):** * In its default **Rollback Journal** mode, if someone is writing, no one else can even *read*.
* In **WAL (Write-Ahead Logging)** mode, SQLite behaves more like Postgres, allowing one writer and multiple readers to coexist. However, it still only allows **one writer at a time** for the entire database.



---

## 3. Transaction Isolation Levels

Transaction isolation determines how "visible" changes in one transaction are to other ongoing transactions.

* **PostgreSQL:** Supports all four standard isolation levels (`Read Uncommitted`, `Read Committed`, `Repeatable Read`, and `Serializable`). The default is `Read Committed`.
* **SQLite:** Effectively only supports `Serializable` and `Read Uncommitted`. Because of its database-level locking, it essentially forces transactions to be serial (one after the other) by default.

---

## 4. Prepared Transactions and Crashes

* **SQLite:** Designed for local storage. If the application crashes, the database recovery is handled the next time the file is opened by any process. It is incredibly robust for power failures but doesn't support "Two-Phase Commit" (distributed transactions).
* **PostgreSQL:** Built for the network. It supports complex features like **Prepared Transactions**, allowing it to coordinate a single transaction across multiple different servers or databases.

---

### Comparison Summary

| Feature | SQLite | PostgreSQL |
| --- | --- | --- |
| **Concurrency** | 1 Writer, Multiple Readers (WAL) | Many Writers, Many Readers |
| **Locking Scope** | Entire Database | Individual Rows |
| **Readers vs Writers** | Readers can block writers (non-WAL) | Readers never block writers |
| **Use Case** | Mobile apps, local tools, low-concurrency | High-traffic web apps, complex systems |

### The "Database is Locked" Error

In SQLite, you will frequently encounter the `SQLITE_BUSY` error if your application tries to write too fast. In PostgreSQL, you almost never see this; instead, the database just manages the queue of row updates automatically.

