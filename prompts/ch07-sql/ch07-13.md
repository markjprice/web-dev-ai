> **Prompt**: Please show me some examples of queries that look correct but silently drop rows because of JOIN choices.

One of the most dangerous aspects of SQL is that a query can be syntactically perfect, run without errors, and return a result set that looks plausibleâ€”all while missing 20% of your data. This usually happens because of "Hidden Filtering."

Here are the most common ways queries silently drop rows.

---

## 1. The "Aggressive" Inner Join

This is the most frequent culprit. Developers often use `JOIN` (which defaults to `INNER JOIN`) when they should have used `LEFT JOIN`.

### The Scenario:

You want a report of all employees and their department names.

```sql
SELECT e.name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.id;

```

* **How it drops rows:** If you have a new hire who hasn't been assigned a `dept_id` yet (it's `NULL`), or if a department was deleted, that employee **vanishes** from the list entirely.
* **The "Correct" Look:** The query looks like a standard list, but the row count is lower than your total employee count.
* **The Fix:** Use `LEFT JOIN` to ensure every employee stays in the result, even if their department is missing.

---

## 2. Filtering the "Optional" Table in the WHERE Clause

This is a "Silent Conversion" where a `LEFT JOIN` is downgraded to an `INNER JOIN` by a later filter.

### The Scenario:

You want a list of all customers and their "VIP" support tickets.

```sql
SELECT c.name, t.issue
FROM customers c
LEFT JOIN tickets t ON c.id = t.customer_id
WHERE t.priority = 'high';

```

* **How it drops rows:** You used `LEFT JOIN`, so you expect to see customers with no tickets. However, the `WHERE` clause checks `t.priority = 'high'`. If a customer has no tickets, `t.priority` is `NULL`. Since `NULL = 'high'` is not true, **every customer without a high-priority ticket is deleted from your results.**
* **The Fix:** Move the filter into the `ON` clause.
```sql
SELECT c.name, t.issue
FROM customers c
LEFT JOIN tickets t ON c.id = t.customer_id AND t.priority = 'high';

```



---

## 3. The Multi-Step Join "Black Hole"

When you chain multiple joins together, a single `INNER JOIN` in the middle of a `LEFT JOIN` chain acts like a funnel that discards everything that doesn't pass through it.

### The Scenario:

Users -> Profiles (Optional) -> Countries (Required for Profile).

```sql
SELECT u.username, p.bio, c.country_name
FROM users u
LEFT JOIN profiles p ON u.id = p.user_id
JOIN countries c ON p.country_id = c.id; -- The Black Hole

```

* **How it drops rows:** Because the join to `countries` is an `INNER JOIN` on the `profiles` table, any user who **doesn't have a profile** is dropped. Even though you started with a `LEFT JOIN` on profiles, the second join requires a match.
* **The Fix:** Ensure the entire chain uses `LEFT JOIN` if the starting set must remain intact.

---

## 4. Anti-Patterns with `COUNT()`

Sometimes rows aren't "dropped" from the result set, but they are "dropped" from your calculations, leading to incorrect business logic.

### The Scenario:

Counting how many comments each post has.

```sql
SELECT p.title, COUNT(c.id) as comment_count
FROM posts p
LEFT JOIN comments c ON p.id = c.post_id
GROUP BY p.title;

```

* **Wait, this is actually correct!** But many developers write this instead: `COUNT(*)`.
* **The Bug:** If you use `COUNT(*)`, a post with **zero** comments will show a count of **1**. Why? Because the `LEFT JOIN` creates one row for that post with `NULL` comment data. `COUNT(*)` counts the row itself.
* **The Fix:** Always count a specific column from the "Right" table (e.g., `COUNT(c.id)`) to ensure `NULL` values aren't counted as active entries.

---

## Summary of "Silent Drop" Risks

| Query Component | The Risk | Result |
| --- | --- | --- |
| **Default `JOIN**` | Misses rows with `NULL` keys. | Incomplete list. |
| **`WHERE` on Right Table** | Converts `LEFT` to `INNER`. | Missing "Empty" records. |
| **Mixed Join Types** | Middle joins filter the whole set. | Unexpectedly small results. |
| **`COUNT(*)` on Left Join** | Overcounts empty relations. | Inflated statistics. |

