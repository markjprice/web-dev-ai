> **Prompt**: Please explain index selectivity and why indexing Boolean columns is often useless.

In database performance tuning, **Selectivity** is the "filter power" of a column. It measures how effectively a column can narrow down the total dataset to find specific rows.

If an index doesn't have enough "filter power," the database engine will ignore it, rendering it a waste of storage and write performance.

---

## 1. What is Index Selectivity?

Selectivity is a mathematical ratio defined by the number of unique values (Cardinality) compared to the total number of rows.

* **High Selectivity (Close to 1.0):** Columns like `email_address` or `user_id`. Each value points to a tiny fraction of the table (ideally one row). These are the **best** candidates for indexing.
* **Low Selectivity (Close to 0.0):** Columns like `gender`, `is_active`, or `country`. A single value might point to 50% or more of the table.

---

## 2. Why Indexing Booleans is Usually Useless

A Boolean column (`true`/`false`) has a maximum cardinality of 2. In a table of 1 million rows, the selectivity is .

When you query `WHERE is_active = true`, the engine faces two choices:

1. **Use the Index:** Search the index, find 500,000 matching locations, and then perform 500,000 "Bookmark Lookups" to fetch the actual rows from the table.
2. **Table Scan:** Read the entire table file sequentially from start to finish.

### The "Tipping Point"

Because sequential reading (Table Scan) is much faster for the hardware than jumping around randomly (Index Lookups), database optimizers usually have a "tipping point." If a query returns more than roughly **5% to 10%** of the table, the optimizer will decide the index is too expensive and perform a Full Table Scan instead.

Since a Boolean usually returns ~50% of the data, the index is almost always ignored. It sits there taking up disk space and slowing down every `INSERT` without ever helping a single `SELECT`.

---

## 3. When is a Boolean Index Useful?

There is one specific scenario where a Boolean index works: **Extreme Skew.**

If you have a table of 1 million "Background Jobs" and 99.9% are `completed = true`, but only 100 are `completed = false`:

* An index on `completed` **is** useful if you are searching for the `false` values.
* The selectivity for that specific query is very high, allowing the engine to jump straight to those 100 rows.

---

## 4. The Pro Move: Partial Indexes

Instead of indexing the entire Boolean column, modern databases like PostgreSQL allow you to create a **Partial Index**. This only indexes the rows that actually matter to your performance.

```sql
-- This index is tiny because it only tracks the "unprocessed" rows
CREATE INDEX idx_pending_tasks ON tasks (created_at)
WHERE is_processed = false;

```

This gives you the best of both worlds: lightning-fast lookups for the "active" data and zero overhead for the millions of "historical" rows.

### Summary Comparison

| Metric | High Selectivity (ID) | Low Selectivity (Boolean) |
| --- | --- | --- |
| **Unique Values** | Millions | 2 |
| **Engine Choice** | Index Seek | Full Table Scan |
| **Storage Cost** | High (but worth it) | Low (but often wasted) |
| **Query Speed** | Instant | Slow (Index is ignored) |

