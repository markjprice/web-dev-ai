> **Prompt**: Why does Python execute module-level code on import? Please explain __name__ == '__main__' in more depth with real examples.

In Python, there is no special "entry point" function like `main()` in C++ or Java. Instead, the Python interpreter reads a script from top to bottom, executing every line it encounters.

When you **import** a module, Python executes all the code at the top level of that file to "build" the module's objects (functions, classes, variables) in memory.

---

## 1. Why execute code on import?

It sounds dangerous, but itâ€™s actually necessary. In Python, `def` and `class` are **executable statements**.

When Python "executes" a `def` block, it isn't running the logic inside the function; it is creating a function object and assigning it a name. If Python didn't execute module-level code, your functions and classes would never be defined, and you wouldn't be able to use them after importing.

### The Danger: "Side Effects"

The problem arises when you have "active" code at the top level, like a `print()` statement or a database connection.

```python
# script_a.py
print("Connecting to Database...") # This is a "Side Effect"
def do_work():
    pass

```

If you `import script_a`, you will see "Connecting to Database..." printed to your console immediately, even if you never intended to run the logic of `script_a`.

---

## 2. The Solution: `if __name__ == "__main__":`

To prevent side effects, Python provides a special built-in variable called `__name__`.

* **Scenario A (Running Directly):** If you run a file directly (`python my_script.py`), Python sets the variable `__name__` to the string `"__main__"`.
* **Scenario B (Importing):** If you import that same file into another script, Python sets `__name__` to the **name of the file** (e.g., `"my_script"`).

By wrapping your "active" code in an `if` statement, you tell Python: **"Only run this if I am the primary script being executed."**

---

## 3. Real-World Example

Imagine you are building a math utility module. You want it to be a library others can use, but you also want a way to test it quickly by running the file.

```python
# math_utils.py

def add(a, b):
    return a + b

# This code will ONLY run if you do: python math_utils.py
if __name__ == "__main__":
    print("Running internal tests...")
    assert add(2, 2) == 4
    print("Tests passed!")

```

### What happens when imported?

If another file does `import math_utils`, the `add` function is defined and ready for use. However, the `if` block evaluates to `False` (because `__name__` is `"math_utils"`), so the tests do **not** run. This keeps your library "clean" for others.

---

## 4. Best Practice: The `main()` function

Professional developers usually combine this pattern with a `main()` function to keep the top level of the script tidy.

```python
def task_a():
    pass

def task_b():
    pass

def main():
    # Organize your execution logic here
    task_a()
    task_b()

if __name__ == "__main__":
    main()

```

---

## Summary Comparison

| Execution Mode | `__name__` value | Result of `if __name__ == "__main__":` |
| --- | --- | --- |
| **`python script.py`** | `"__main__"` | **True** (Code runs) |
| **`import script`** | `"script"` | **False** (Code is skipped) |

### Pro-Tip: Avoid Global Logic

Always keep your module-level code limited to `def`, `class`, and constant definitions (like `PI = 3.14`). Any code that "does work" (API calls, file writing, printing) should be safely tucked inside a function or a `__main__` block.

