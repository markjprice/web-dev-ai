> **Prompt**: How would this task tracker change if it used a database instead of JSON? What would it take to turn this script into a web application? Which parts of this project map directly to Django concepts?

Moving from a flat JSON file to a database is a major architectural shift. You are essentially moving from **Document-based storage** (where you have to load the whole file to change one word) to **Relational storage** (where you can surgically update a single row).

---

## 1. How the Tracker Changes: JSON vs. Database

In your current script, every time a user adds a task, you likely read the entire JSON file into memory, append to a list, and overwrite the whole file. With a database (like SQLite or PostgreSQL), this workflow is fundamentally different.

### Technical Shifts

* **Concurrency:** JSON files "lock" when one person writes. A database allows multiple people to update different tasks simultaneously.
* **Partial Updates:** In JSON, you can't "just" update task #5. In a database, you use `UPDATE tasks SET status = 'done' WHERE id = 5;`. This is significantly faster and uses less RAM.
* **Relationships:** If you wanted to add "Users" to your tracker, a database lets you link a `task` to a `user_id` effortlessly. Doing this in JSON requires complex nesting that gets messy fast.

---

## 2. Turning the Script into a Web App

To turn a Python script into a web application, you need to introduce an **HTTP Server** to act as a bridge between the browser and your logic.

### The "Stack" Requirements:

1. **A Web Framework:** You need a library like **Flask** or **Django** to handle "Routes" (e.g., when a user visits `/tasks`, run the `show_tasks()` function).
2. **HTML Templates:** Instead of `print()` statements in a terminal, youâ€™ll write HTML files that tell the browser how to display the data.
3. **An API or Form System:** You need a way for the browser to send data (like a new task) back to your Python code via `POST` requests.
4. **Static Hosting:** You need a place for your CSS (styling) and JavaScript to live.

---

## 3. Mapping to Django Concepts

If you chose **Django** as your web framework, your existing script logic maps almost perfectly to the **MVT (Model-View-Template)** architecture.

| Current Script Part | Django Concept | What it does in Django |
| --- | --- | --- |
| **JSON Schema / Structure** | **Model** | Defines the "shape" of your data in a Python class. Django creates the database tables for you. |
| **Main Logic / Functions** | **View** | The "brain." It fetches data from the Model and decides which Template to show. |
| **`print()` and formatting** | **Template** | HTML files with special placeholders (e.g., `{{ task.name }}`) to display data. |
| **`if __name__ == "__main__"`** | **URLs / Routing** | A `urls.py` file that maps web addresses to your specific functions. |
| **The JSON file itself** | **Database (ORM)** | Django uses an Object-Relational Mapper so you can type `Task.objects.all()` instead of writing SQL. |

---

## The Biggest Change: State Management

In a script, your variables stay in memory as long as the script is running. In a web app, the "server" starts and stops for every click. You cannot rely on global variables; you must save every change to the database immediately, or it will be "forgotten" the moment the page finishes loading.


