> **Prompt**: What coding habits separate beginner Python developers from professionals?

Moving from a beginner to a professional Python developer is less about learning obscure syntax and more about embracing **Pythonic** idioms and writing code that is "boring" (highly readable, predictable, and maintainable).

Here are the key habits that separate the two levels.

---

## 1. Lists: Loops vs. Comprehensions

Beginners often use C-style patterns to transform data. Professionals leverage Python's built-in syntax to make intent clear.

* **Beginner:** Creating an empty list and using `.append()` inside a `for` loop.
* **Professional:** Using **List Comprehensions** or Generator Expressions.

```python
# Beginner (Imperative)
squares = []
for i in range(10):
    if i % 2 == 0:
        squares.append(i * i)

# Professional (Declarative/Pythonic)
squares = [i * i for i in range(10) if i % 2 == 0]

```

## 2. Resource Management: Manual vs. Context Managers

Handling files or database connections manually is a hallmark of beginner code, often leading to memory leaks or locked files when errors occur.

* **Beginner:** Opening a file and remembering to call `.close()` at the end.
* **Professional:** Using the `with` statement (**Context Managers**).

```python
# Beginner (Risky)
f = open("data.txt", "w")
f.write("Hello")
# If an error happens here, the file stays open
f.close()

# Professional (Safe)
with open("data.txt", "w") as f:
    f.write("Hello")
# File closes automatically, even if an error occurs

```

## 3. Data Structures: Lists vs. Sets and Dicts

Beginners treat the `list` as a "silver bullet" for every collection. Professionals choose the structure based on the **Time Complexity** of the operation.

* **Beginner:** Using `if item in my_list:` (which takes  time).
* **Professional:** Using a `set` for membership tests (which takes  time).

## 4. Documentation: Comments vs. Docstrings and Type Hints

Beginners explain *what* the code does with comments. Professionals explain *why* it exists and what it expects using modern Python features.

* **Beginner:** Using `#` to describe every line.
* **Professional:** Using **Type Hints** and **Docstrings**.

```python
# Beginner
def calc(a, b): # adds two numbers
    return a + b

# Professional
def calculate_total_price(price: float, tax_rate: float) -> float:
    """Calculates the total price including tax."""
    return price * (1 + tax_rate)

```

## 5. Error Handling: "Ask Permission" vs. "Ask Forgiveness"

This is a core cultural difference in Python.

* **Beginner (LBYL - Look Before You Leap):** Checking if a key exists before accessing it.
* **Professional (EAFP - Easier to Ask Forgiveness than Permission):** Attempting the operation and catching the specific exception.

```python
# Beginner
if "key" in my_dict:
    val = my_dict["key"]

# Professional
try:
    val = my_dict["key"]
except KeyError:
    val = "default"
# Or even better:
val = my_dict.get("key", "default")

```

---

## Summary Comparison

| Habit | Beginner Pattern | Professional Pattern |
| --- | --- | --- |
| **Iteration** | `for i in range(len(arr)):` | `for item in arr:` or `enumerate()` |
| **Conditionals** | `if x == True:` | `if x:` |
| **Path Handling** | String concatenation (`"dir/" + f`) | `pathlib.Path` |
| **Packaging** | One giant `.py` file | Modular packages with `__init__.py` |
| **Libraries** | Reinventing the wheel | Using `itertools`, `collections`, `pathlib` |

### The "Pro" Toolbox

Professionals rarely write raw logic for common tasks. They rely on the **Standard Library**:

* `collections.defaultdict` for building dictionaries.
* `itertools` for complex looping.
* `logging` instead of `print()` for debugging.


