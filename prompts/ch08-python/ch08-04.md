> **Prompt**: Please show me some examples where type hints prevent bugs without changing runtime behavior.

Type hints in Python act like a "contract" that tools like **Mypy**, **Pyright**, or your IDE (VS Code/PyCharm) use to audit your code before it ever runs. Because Python ignores these hints at runtime, they provide safety without sacrificing the language's dynamic speed.

Here are three classic bugs that type hints catch during development.

---

## 1. The "None" Reference (The Billion Dollar Mistake)

In dynamic Python, it is incredibly easy to forget that a function might return `None` (e.g., if a record isn't found), leading to the dreaded `AttributeError: 'NoneType' object has no attribute...`.

### The Bug (Without Hints):

```python
def get_user_email(user_id):
    user = db.find(user_id) # Might return None
    return user.email       # Crashes here if user is None

```

### The Prevention (With Hints):

```python
from typing import Optional

class User:
    email: str

def get_user_email(user_id: int) -> Optional[str]:
    user = db.find(user_id)
    return user.email  # Mypy Error: "User" may be None

```

**The Fix:** Your IDE will underline `user.email` in red, forcing you to add an `if user:` check before accessing the attribute.

---

## 2. The "Incompatible Types" Math Bug

Python will happily let you pass a string into a function expecting a number, only to fail later when you try to perform math or database operations.

### The Bug (Without Hints):

```python
def calculate_tax(amount, rate):
    return amount * rate

# ... elsewhere in the code ...
calculate_tax("100", 0.05) # Result: "100100100100100" (String multiplication!)

```

### The Prevention (With Hints):

```python
def calculate_tax(amount: float, rate: float) -> float:
    return amount * rate

calculate_tax("100", 0.05) # Static Analysis Error: Argument 1 has incompatible type "str"

```

---

## 3. The "Missing Key" in Dictionary-like Objects

When passing around complex data structures, it's easy to misspell a key or assume a field exists when it doesn't. `TypedDict` provides a schema for your dictionaries.

### The Prevention (With TypedDict):

```python
from typing import TypedDict

class Movie(TypedDict):
    title: str
    year: int

def display_movie(m: Movie):
    print(f"{m['title']} ({m['year']})")

display_movie({"title": "Inception", "yr": 2010}) 
# Static Analysis Error: Extra key "yr", missing key "year"

```

---

## Why This Matters

* **Documentation:** Type hints tell other developers exactly what a function needs without them having to read the entire function body.
* **IDE Autocomplete:** When you hint a variable as a specific class, your IDE can suggest its methods and attributes accurately.
* **Refactoring:** If you change a function signature, the type checker will instantly list every single file in your project that needs to be updated.

### Summary of Impact

| Feature | Without Type Hints | With Type Hints |
| --- | --- | --- |
| **Error Discovery** | At Runtime (user finds it) | At Dev-time (editor finds it) |
| **Refactoring** | Manual search and pray | Automated and verified |
| **Logic Clarity** | Implicit (guesswork) | Explicit (documented) |
| **Performance** | No change | No change |


