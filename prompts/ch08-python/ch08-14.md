> **Prompt**: How should I decide whether to catch an exception or let it crash?

Deciding whether to catch an exception or let a program crash is the difference between **Resilience** and **Silent Failure**. In professional development, "letting it crash" is actually a valid strategy in many scenarios.

The golden rule is: **Only catch an exception if you can actually do something useful with it.**

---

## 1. When to Catch (Handle)

You should catch an exception when the error is **expected**, **recoverable**, or needs to be **translated** for the user.

### A. The "Retry" Scenario

If a network request fails due to a temporary glitch, you catch the error and try again.

```python
try:
    response = requests.get("https://api.example.com/data")
except ConnectionError:
    # We can handle this by waiting and retrying
    time.sleep(1)
    response = requests.get("https://api.example.com/data")

```

### B. The "Fallback" Scenario

If a configuration file is missing, you catch the error and provide default settings.

```python
try:
    with open("config.json") as f:
        settings = json.load(f)
except FileNotFoundError:
    settings = {"theme": "light", "language": "en"} # Valid recovery

```

### C. The "Cleanup" Scenario

You catch the error to ensure resources (like database connections) are closed before the program exits or moves on.

---

## 2. When to Let it Crash (Propagate)

Letting a program crash (or "failing fast") is often better than catching an error and continuing in a "zombie state" where data could become corrupted.

### A. Fatal Configuration Errors

If your app cannot connect to its primary database at startup, catching the error and showing an empty screen is worse than crashing. A crash tells the developer/sysadmin exactly what is wrong via a **Stack Trace**.

### B. Programming Logic Errors (Bugs)

If you have an `IndexError` or a `TypeError`, these are bugs in your logic. Catching them with a "Pokemon" catch (`except Exception: pass`) hides the bug and makes it nearly impossible to find later.

> **Crucial Tip:** Never use a bare `except: pass`. It swallows every error, including keyboard interrupts (Ctrl+C), making the program impossible to stop.

### C. You Don't Know How to Fix It

If your function is supposed to save a file and the disk is full, and you don't have a way to free up space, don't catch the error. Let the calling function handle it, or let the program crash so the user knows their data wasn't saved.

---

## 3. The "Exception Hierarchy" Strategy

Professional code usually follows this flow:

1. **Low-Level Functions:** Let exceptions bubble up (don't catch).
2. **Mid-Level Functions:** Catch specific errors to add context (e.g., "Error processing User #10: [original error]").
3. **High-Level (Top) Functions:** Use a "Global Exception Handler" to log the error to a file and show a friendly message to the user before closing gracefully.

---

## Decision Matrix

| Situation | Action | Why? |
| --- | --- | --- |
| **Temporary Network Issue** | **Catch** | You can retry or go offline. |
| **Missing Optional File** | **Catch** | You can use defaults. |
| **Typo in Code (`NameError`)** | **Let it Crash** | It's a bug that needs fixing. |
| **Database Connection Fail** | **Let it Crash** | The app can't function anyway. |
| **User Inputted String for Number** | **Catch** | You can ask the user to try again. |

### Pro-Tip: The `finally` Clause

Even if you don't catch an error, you can use `finally` to ensure code runs regardless of whether a crash occurs.

```python
file = open("data.txt")
try:
    process_data(file)
finally:
    file.close() # This runs even if process_data() crashes!

```


