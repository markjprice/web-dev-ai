> **Prompt**: Please show me some common mistakes with circular imports and how to avoid them.

A **Circular Import** occurs when Module A tries to import Module B, but Module B is already in the middle of trying to import Module A. This creates a "chicken and egg" problem where neither module can finish initializing because they are waiting on each other.

In Python, this often results in a confusing `ImportError` or `AttributeError` because one of the modules is only "partially loaded" when its functions are called.

---

## 1. How a Circular Import Happens

Imagine two files in the same directory:

**`user.py`**

```python
from post import Post

class User:
    def create_post(self, text):
        return Post(text, self)

```

**`post.py`**

```python
from user import User

class Post:
    def __init__(self, text, author):
        self.text = text
        self.author = author # Expects a User object

```

### The Crash:

When you run `python user.py`:

1. `user.py` starts and hits `from post import Post`.
2. Python pauses `user.py` and goes to load `post.py`.
3. `post.py` hits `from user import User`.
4. Python sees `user.py` is already being loaded, but the `User` class hasn't been defined yet (because we are still on line 1 of `user.py`!).
5. **Boom:** `ImportError: cannot import name 'User' from partially initialized module 'user'`.

---

## 2. Common Mistake: Shadowing Standard Libraries

Beginners often accidentally create circular imports by naming their files after built-in libraries.

* **The Scenario:** You create a file named `json.py`.
* **The Error:** You write `import json` inside your file. Python finds *your* file first. Your file then tries to import `json` (itself), creating a circular loop that crashes before it even starts.

---

## 3. How to Avoid and Fix Circular Imports

### Method A: Move the Import Inside the Function (Lazy Import)

This is the quickest fix. By moving the `import` statement inside the method, it doesn't run when the file is first loaded—it only runs when the function is actually called.

```python
# user.py
class User:
    def create_post(self, text):
        from post import Post  # Import happens only when called
        return Post(text, self)

```

### Method B: Refactor Common Code

If two modules depend on each other, they often share a common piece of logic. Move that shared logic into a **third module** that both can import.

* **Before:** `A <-> B`
* **After:** `A -> C`, `B -> C` (where C contains the shared base classes or constants).

### Method C: Use "Type Hinting" Strings

If you only need the import for type hints, you can use a string or the `TYPE_CHECKING` constant. This allows tools like Mypy to see the type, but the Python interpreter ignores the import at runtime.

```python
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from post import Post # Only seen by type checkers

class User:
    def add_post(self, post: "Post"): # Use a string here
        print(post.text)

```

---

## Summary of Solutions

| Solution | Best For... | Pros/Cons |
| --- | --- | --- |
| **Lazy Import** | Quick fixes in methods. | Pro: Simple. Con: Can hide import errors until runtime. |
| **Third Module** | Structural architectural issues. | Pro: Cleanest design. Con: Requires more files. |
| **Absolute Imports** | Preventing name collisions. | Pro: Explicit. Con: Doesn't fix true logic loops. |
| **Type Checking** | Resolving hints only. | Pro: No runtime overhead. Con: Only helps with types. |

### Pro-Tip: The "Architectural" Hint

If you have a circular import, it’s often a sign that your modules are **too tightly coupled**. In a well-designed system, dependencies should flow in one direction (e.g., `UI -> Business Logic -> Database`). If the Database needs to know about the UI, the layers are likely mixed up.


