> **Prompt**: Why does my Bash script exit early when I use `set -e`?

When you add `set -e` (often called **errexit**) to your script, you are changing Bash from its "chill" default mode to a "strict" mode.

By default, Bash is an optimist: if a command fails, it prints an error to the screen but keeps right on going to the next line. With `set -e`, Bash becomes a perfectionist: the moment **any** command returns a non-zero exit code (indicating failure), the entire script terminates immediately.

---

## 1. The "Exit Code" Mechanic

Every command in Linux returns a number between 0 and 255 when it finishes.

* **0:** Success ("Everything went fine").
* **Anything else (1-255):** Failure ("Something went wrong").

With `set -e`, Bash checks the "state" of the variable `$?` (which holds the exit code of the last command) after every single line. If `$?` is not `0`, it kills the script.

---

## 2. Common Reasons for "Mysterious" Early Exits

Sometimes scripts exit early on commands you didn't even realize could "fail."

### A. The `grep` Trap

If you use `grep` to search for a string and it **doesn't find it**, `grep` returns an exit code of `1`.

```bash
set -e
grep "error" log.txt  # If "error" isn't in the file, the script dies here!
echo "I found it!"    # This line never runs

```

### B. The `test` or `[` Pitfall

If you perform a check that evaluates to false, the command technically "fails."

```bash
set -e
[ -f "optional_config.txt" ] # If file doesn't exist, exit code is 1. Script dies.

```

### C. Commands at the end of a Pipe

In a pipe like `command1 | command2`, `set -e` only looks at the exit code of the **last** command (`command2`). If `command1` crashes but `command2` succeeds, the script keeps runningâ€”unless you also use `set -o pipefail`.

---

## 3. How to Prevent "Good" Failures from Killing the Script

Sometimes you *expect* a command might fail and you don't want the script to die. You can "neutralize" the exit code using the OR operator (`||`).

```bash
set -e

# "Try to delete this, but I don't care if it's already gone"
rm temporary_file.txt || true 

# "Search for a user, but keep going even if not found"
grep "admin" users.list || echo "User not found, continuing..."

```

---

## 4. Why use it at all?

Experienced developers use `set -e` to prevent **cascading failures**.

Recall the dangerous example from earlier:

```bash
cd /backup_dir
rm -rf *

```

Without `set -e`, if `cd` fails (directory missing), the script stays in your current folder and deletes everything. With `set -e`, the script stops at the `cd` line, saving your data.

---

### Pro-Tip: The "Safe Mode" Header

Most professional Bash scripts start with this "holy trinity" of safety settings:

```bash
#!/usr/bin/env bash
set -euo pipefail

```

* **`-e`**: Exit on error.
* **`-u`**: Exit if you try to use an undefined variable (prevents typos).
* **`-o pipefail`**: Ensure that if *any* part of a pipe fails, the whole script exits.

