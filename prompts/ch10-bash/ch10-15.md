> **Prompt**: How can I safely debug a Bash script step by step?

Debugging a Bash script is a bit different from using a traditional "debugger" in an IDE like VS Code for Python or C++. In Bash, debugging is usually done by telling the shell to be more "talkative" about what it is doing behind the scenes.

Here is the safest, step-by-step approach to diagnosing a broken script.

---

## 1. Use the "Trace" Mode (`-x`)

The most powerful tool in your arsenal is the **`-x`** (xtrace) flag. This tells Bash to print every command to the terminal *after* it has expanded variables but *before* it executes them.

### Method A: Run the script with the flag

You don't even need to change your code. Just run it like this:

```bash
bash -x ./myscript.sh

```

### Method B: Debug only a specific section

If your script is 500 lines long, you don't want to see every line. You can "wrap" the problematic section:

```bash
# Normal execution
echo "Starting..."

set -x  # Turn on debugging
grep "$pattern" "$file"
set +x  # Turn off debugging

# Normal execution continues
echo "Done."

```

---

## 2. Check Syntax Without Running (`-n`)

If you are worried that your script might delete files or cause damage while you are debugging it, use the **`-n`** (noexec) flag.

```bash
bash -n ./myscript.sh

```

Bash will read the script and look for syntax errors (like missing `fi` or `done` tags) but **will not execute a single command**. If it finds nothing wrong, it returns no output.

---

## 3. The "Manual Breakpoint" (The `read` Trick)

If you want to step through your script line-by-line manually, you can insert a `read` command. This pauses the script and waits for you to hit **Enter**.

```bash
echo "About to delete temporary files..."
read -p "Press Enter to continue or Ctrl+C to abort..."
rm -rf ./tmp/*

```

---

## 4. Inspecting the "Environment State"

Sometimes a script fails because a variable isn't what you think it is. You can use the `declare -p` command to see exactly how a variable is defined.

```bash
# Inside your script:
declare -p MY_VARIABLE

```

This is better than `echo` because it will show you if the variable is an array, an integer, or if it contains hidden spaces/newlines.

---

## 5. Use `trap` to Catch Errors

You can tell Bash to run a specific command whenever something goes wrong. This is like a "post-mortem" report.

```bash
#!/usr/bin/env bash

# This function runs whenever the script exits
cleanup() {
  echo "Script exited at line $1. Current directory: $(pwd)"
}

trap 'cleanup $LINENO' ERR

```

---

## 6. The "Gold Standard": ShellCheck

Before you even run your script, run it through **ShellCheck**. It acts as a static analysis tool that catches common logic errors that `-x` might miss, such as:

* Forgetting to quote a variable.
* Using `[` instead of `[[`.
* Accidental assignments in `if` statements.

---

### Summary Checklist for Debugging

1. **Run `shellcheck script.sh**` to find syntax bugs.
2. **Run `bash -n script.sh**` to ensure it's "legal" Bash.
3. **Run `bash -x script.sh**` to see exactly what is happening in real-time.
4. **Add `set -u**` to the top to catch typos in variable names.

# A Debugger Helper function

This helper function is a "safety net" you can paste into any script. It uses a **trap** to catch errors and provides a detailed report of exactly what went wrong, including the line number and the command that failed.

---

## The "Debug & Safety" Header

Copy this block to the top of your scripts (right after the shebang):

```bash
#!/usr/bin/env bash

# 1. Safety flags (Exit on error, unset variables, and pipe failures)
set -euo pipefail

# 2. The Debugger Helper Function
failure_report() {
    local exit_code=$?
    local line_number=$1
    echo "---"
    echo "‚ùå ERROR: Script failed at line $line_number"
    echo "üìÑ Command: $BASH_COMMAND"
    echo "üìü Exit Code: $exit_code"
    echo "---"
    exit $exit_code
}

# 3. Set the trap to trigger the function on any error
trap 'failure_report $LINENO' ERR

```

---

## Why this is helpful

When a standard Bash script fails with `set -e`, it usually just disappears silently. With this helper:

* **You get the line number:** You don't have to guess where the script died.
* **You see the command:** It captures the exact command (via `$BASH_COMMAND`) that caused the failure.
* **It cleans up:** Because it's a "trap," it catches the error even if it happens deep inside a function.

---

## Adding a "Verbose" Toggle

If you want to be able to turn on "Trace Mode" (`-x`) only when you need it, add this logic below the header:

```bash
# Run script with DEBUG=true ./myscript.sh to see every step
if [[ "${DEBUG:-false}" == "true" ]]; then
    set -x
fi

```

### How to use it:

1. **Normal run:** `./myscript.sh` (Runs quietly, only reports if it crashes).
2. **Debug run:** `DEBUG=true ./myscript.sh` (Shows every variable expansion and command execution).

---

## One Final Tip: The "Dry Run" Option

If you are writing a script that deletes or moves files, you can add a `DRY_RUN` variable to your logic:

```bash
# Example usage
DEST="./backup"
[[ "${DRY_RUN:-false}" == "true" ]] && echo "[DRY RUN] Would run: rm -rf $DEST" || rm -rf "$DEST"

```

This allows you to test the logic safely by running `DRY_RUN=true ./myscript.sh` without actually losing any data.

