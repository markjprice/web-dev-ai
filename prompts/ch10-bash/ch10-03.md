> **Prompt**: What does it mean that Bash is stateful, and how does that affect scripts?

In the context of programming and system administration, **statefulness** means that the shell "remembers" information from one command to the next within the same session. When you open a Bash session, it creates an environment that holds data, settings, and history until you close that window or exit the script.

---

## How "State" Works in Bash

Think of a Bash session as a **room**. Once you enter the room, you can put up posters (set variables), change the temperature (set environment paths), or move furniture (change directories). Those changes stay exactly as you left them until you leave the room.

### Key Elements of the Bash State:

* **Variables:** If you type `NAME="Alex"`, the shell stores that in memory.
* **Working Directory:** The shell remembers where you are (e.g., `/home/user/docs`).
* **History:** It remembers the last 500+ commands you typed.
* **Permissions:** It knows your current user ID and what you are allowed to touch.

---

## How Statefulness Affects Scripts

This "memory" is a double-edged sword. It makes automation powerful, but it also creates common pitfalls for developers.

### 1. The Environment Leak

If you run a script that changes a variable, that change usually stays inside the script's "sub-shell" and doesn't affect your main terminal. However, if you **source** a script (using `source script.sh` or `. script.sh`), the script runs inside your *current* state.

* **The Risk:** A script could accidentally overwrite a system variable like `PATH`, breaking your terminal session until you restart it.

### 2. Order of Operations

Because Bash is stateful, the result of "Command B" often depends entirely on "Command A."

* **Example:**
```bash
cd /tmp/backups
rm -rf *

```


If the first command (`cd`) fails because the folder doesn't exist, the state remains in your current directory (perhaps your home folder). The second command (`rm -rf *`) will then proceed to delete everything in the *wrong* directory.

### 3. Persistence via Export

You can move "state" from a parent shell to a child shell using the `export` command.

* **Concrete Example:** If you set `API_KEY="123"`, a script you run won't see it. If you set `export API_KEY="123"`, it becomes part of the "environment state" inherited by any program you launch from that terminal.

---

## Best Practices for Managing State

To prevent state-related bugs in your scripts, developers often use these "safety switches" at the top of their files:

* **`set -e`:** Tells the script to exit immediately if any command fails (prevents the `cd` failure example above).
* **`set -u`:** Treats unset variables as an error (prevents acting on "empty" state).
* **Local Variables:** Using the `local` keyword inside functions ensures that variables don't "leak" out and mess up the rest of the script's state.

---

> **The "Stateless" Alternative:** This is why tools like **Docker** or **Serverless functions** are so popular. They aim to be "stateless"â€”every time they run, they start with a perfectly clean slate, ensuring that a leftover variable from a previous run doesn't cause a crash.

