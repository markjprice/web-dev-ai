> **Prompt**: What are the most common Django conventions that beginners try to fight, and why is it usually better to follow them?

It is often said that Django is "batteries-included," but those batteries come with a very specific instruction manual. Beginners often feel that Django is "too opinionated" and try to find workarounds to make it behave like other frameworks (like Flask or Express).

Here are the conventions people usually fight, and why the "Django Way" eventually wins.

---

## 1. Fat Models, Thin Views

**The Struggle:** Beginners often put all their complex logic—like calculating a price, sending an email, or processing an image—inside the `views.py`.
**Why they fight it:** It feels natural to put the logic where the request is handled.
**Why follow it:** * **Reusability:** If you put logic in the **Model**, you can use it in the web view, the admin panel, and your background tasks without rewriting it.

* **Testing:** It is much easier to write a unit test for a model method than it is to mock an entire HTTP request for a view.

---

## 2. Using the Django Admin for Everything

**The Struggle:** Beginners often try to build a custom "Dashboard" or "CMS" from scratch immediately.
**Why they fight it:** The default Admin looks "too basic" or they want full control over the UI for staff members.
**Why follow it:** * **The 80/20 Rule:** You can build 80% of your internal management tools in minutes by registering models in `admin.py`.

* **Security:** The Admin has built-in, granular permission sets that are notoriously difficult to get right when building from scratch. Use the Admin for staff, and save your custom coding for the public-facing site.

---

## 3. The "Apps" Structure

**The Struggle:** Beginners often try to put everything into one single folder, or they get confused about why they need a `users` app, a `blog` app, and a `products` app.
**Why they fight it:** It feels like unnecessary "boilerplate" and creates more files to manage.
**Why follow it:** * **Pluggability:** Django is designed so that you can literally copy an `app` folder from one project to another.

* **Mental Models:** When your project grows to 50+ models, having them separated by domain (e.g., `billing`, `inventory`) prevents the "God File" problem where one `models.py` is 3,000 lines long.

---

## 4. Avoiding Raw SQL (Trust the ORM)

**The Struggle:** Someone who knows SQL well will often try to bypass the ORM and write `connection.execute("SELECT...")`.
**Why they fight it:** They think the ORM is slow or they find Django’s "double underscore" syntax (e.g., `filter(author__name__icontains="..."))` confusing.
**Why follow it:** * **Security:** The ORM automatically prevents SQL Injection.

* **Database Agnostic:** If you write raw SQL for PostgreSQL and your boss decides to switch to MySQL, you have to rewrite your code. With the ORM, you just change one line in `settings.py`.

---

## 5. Using the Built-in User Model

**The Struggle:** Beginners often try to create their own `Profile` model from scratch for logins.
**Why they fight it:** They want users to log in with an email instead of a username, or they find the default User model restrictive.
**Why follow it:** * **The Ecosystem:** Almost every third-party Django package (for payments, social login, etc.) expects you to use `AbstractUser`.

* **Convention:** Even if you want to change the fields, Django recommends **extending** the user model rather than ignoring it.

---

## 6. Project Settings Management

**The Struggle:** Putting API keys and database passwords directly into `settings.py`.
**Why they fight it:** It’s faster and easier than setting up environment variables.
**Why follow it:** * **Security:** Once you `git push` that file, your secrets are public forever.

* **Environment Parity:** You need different settings for "Development" (on your laptop) and "Production" (on the web). Following the convention of using `.env` files makes this seamless.

# How to properly **extend the User Model** using a `CustomUser`

This is arguably the most important "Day 1" task in any Django project. If you try to change the User model halfway through a project, it’s a database migration nightmare. Doing it upfront is the "Django Way."

To do this properly, we use **`AbstractUser`**. This gives you all the power of the default user (password hashing, permissions, groups) but lets you add your own fields.

---

### 1. Define the Custom User (`models.py`)

Instead of just using the default, we create a class that inherits from `AbstractUser`.

```python
from django.contrib.auth.models import AbstractUser
from django.db import models

class CustomUser(AbstractUser):
    # Add your own custom fields here
    email = models.EmailField(unique=True) # Make email required and unique
    bio = models.TextField(blank=True)
    birth_date = models.DateField(null=True, blank=True)
    is_premium_member = models.BooleanField(default=False)

    # Use email to log in instead of a username
    USERNAME_FIELD = 'email'
    REQUIRED_FIELDS = ['username'] # Django still needs a username internally

```

---

### 2. Tell Django to Use It (`settings.py`)

By default, Django looks for `auth.User`. You have to point it to your new model. Assuming your app is named `users`:

```python
# settings.py
AUTH_USER_MODEL = 'users.CustomUser'

```

---

### 3. Update the Admin (`admin.py`)

Since you changed the model, the standard Admin won't know how to handle your new fields. You need to extend the `UserAdmin` class.

```python
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import CustomUser

class CustomUserAdmin(UserAdmin):
    model = CustomUser
    # This tells the admin which fields to show when editing a user
    fieldsets = UserAdmin.fieldsets + (
        (None, {'fields': ('bio', 'birth_date', 'is_premium_member')}),
    )

admin.site.register(CustomUser, CustomUserAdmin)

```

---

### Why this is better than a "Profile" Model

Many beginners create a separate `Profile` model with a `OneToOneField` to the User. While that works, it has a hidden performance cost:

* **The Profile Way:** Every time you want the user's bio, Django has to do a **Database Join** (SQL `JOIN`) to fetch the second table.
* **The CustomUser Way:** Everything is in one table. When you fetch `request.user`, you have the bio, birth date, and premium status immediately available without extra queries.

### The Golden Rule

**Do this before your first migration.** If you have already run `python manage.py migrate`, you’ll usually have to delete your database and migrations folder to switch to a `CustomUser`. It's a rite of passage for Django developers, but one I'd love for you to avoid!

# How to use **`select_related`** or **`prefetch_related`** to stop Django from making too many database queries

This is the secret to making Django apps feel "snappy." By default, the Django ORM is **lazy**. It only fetches exactly what you ask for, which sounds efficient but can lead to the "N+1 Problem."

### The N+1 Problem

Imagine you have 10 comments on a blog post. If you loop through them in a template to show the author’s name:

1. Django makes **1 query** to get the list of comments.
2. Then, for **each** of the 10 comments, it makes **1 extra query** to fetch the author's details from the User table.
**Total: 11 queries** for one simple list. If you have 100 comments, that's 101 queries. This will crawl your database to a halt.

---

## 1. `select_related` (The "SQL JOIN")

Use this for **Single-value relationships** (`ForeignKey` or `OneToOne`). It tells Django to perform a SQL `JOIN` and include the related object's fields in the initial query.

**The Efficient Way:**

```python
# Instead of this:
comments = Comment.objects.all()

# Do this:
comments = Comment.objects.select_related('author').all()

```

* **Queries:** Reduced from **N+1** down to **1**.
* **Result:** Django fetches the comment data and the author data in a single "big" table.

---

## 2. `prefetch_related` (The "Two-Step Fetch")

Use this for **Multi-value relationships** (`ManyToManyField` or a reverse `ForeignKey`).

Since you can't cleanly "Join" a single row to many rows without massive data duplication, Django does a smart two-step:

1. Fetch all the main objects (e.g., all BlogPosts).
2. Fetch all the related objects (e.g., all Tags) in one separate query using an `IN` clause.
3. "Glue" them together in Python.

**The Efficient Way:**

```python
# Get all posts and all their tags in just 2 queries
posts = BlogPost.objects.prefetch_related('tags').all()

```

---

## Comparison Cheat Sheet

| Feature | `select_related` | `prefetch_related` |
| --- | --- | --- |
| **Relationship** | ForeignKey, OneToOne | ManyToMany, reverse ForeignKey |
| **How it works** | SQL `JOIN` | Two separate queries + Python joining |
| **Database Hits** | Always 1 | Always 2 |
| **Use Case** | "Give me the comment **and its** author." | "Give me the post **and all its** tags." |

---

### Pro-Tip: The "Silently Killing Performance" Check

You can't see these extra queries in your terminal by default. Most Django developers use a tool called **Django Debug Toolbar**. It adds a panel to your browser that shows exactly how many queries were fired for the current page and which ones were duplicates.

