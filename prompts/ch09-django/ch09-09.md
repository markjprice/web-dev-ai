> **Prompt**: How do I change the database system used in a Django project from SQLite to PostgreSQL or SQL Server?

Moving from SQLite to a production-grade database like **PostgreSQL** or **SQL Server** is a standard step when a project grows. SQLite is a single file on your disk, whereas PostgreSQL and SQL Server are separate, powerful services that can handle hundreds of simultaneous connections.

Here is the step-by-step process to make the switch.

---

## 1. Install the Database Driver

Python needs a specific "adapter" to talk to these databases. You must install the driver via `pip` in your terminal.

* **For PostgreSQL:** Use `psycopg2` (the most popular and stable).
```bash
pip install psycopg2-binary

```


* **For SQL Server:** Use `django-mssql-backend`.
```bash
pip install django-mssql-backend

```



---

## 2. Update `settings.py`

You need to change the `DATABASES` dictionary. This tells Django to stop looking at a local file and start looking for a network service.

### Example for PostgreSQL:

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'your_db_name',
        'USER': 'your_db_user',
        'PASSWORD': 'your_password',
        'HOST': 'localhost',  # Or the IP of your DB server
        'PORT': '5432',       # Standard Postgres port
    }
}

```

### Example for SQL Server:

```python
DATABASES = {
    'default': {
        'ENGINE': 'mssql',
        'NAME': 'your_db_name',
        'USER': 'your_db_user',
        'PASSWORD': 'your_password',
        'HOST': 'your_server_name',
        'PORT': '1433',
        'OPTIONS': {
            'driver': 'ODBC Driver 17 for SQL Server',
        },
    }
}

```

---

## 3. Create the Database Manually

Django can create **tables**, but it cannot create the **database** itself. Before running migrations, you must log into your database tool (like pgAdmin or SQL Server Management Studio) and create an empty database with the name you specified in `settings.py`.

---

## 4. Migration & Data Transfer

If you are starting a **fresh project**, just run:

```bash
python manage.py migrate

```

Django will build all your tables in the new database.

### If you have existing data in SQLite:

Transferring data between different database types can be tricky because of how they handle IDs and types. The most reliable "Django Way" is:

1. **Dump Data:** While still on SQLite, run `python manage.py dumpdata > data.json`.
2. **Switch Settings:** Update `settings.py` to the new database.
3. **Migrate:** Run `python manage.py migrate` on the new empty database.
4. **Load Data:** Run `python manage.py loaddata data.json`.

---

## 5. Summary of Differences

| Feature | SQLite | PostgreSQL / SQL Server |
| --- | --- | --- |
| **Storage** | Single `.sqlite3` file. | Dedicated Server/Service. |
| **Concurrency** | Limited (one writer at a time). | High (many simultaneous users). |
| **Setup** | Zero configuration. | Requires installation & users. |
| **Deployment** | Not recommended for production. | Standard for production. |

---

### A Critical Security Warning

Never hardcode your database passwords directly in `settings.py` if you plan to share your code or push to GitHub. Use **Environment Variables** or a `.env` file to keep your credentials secret.

# How to set up a **`.env`** file and use the `python-dotenv` library to keep your database passwords secure

Security is a non-negotiable step once you move away from a local SQLite file. Hardcoding your PostgreSQL or SQL Server credentials in `settings.py` is a major risk, especially if you ever push your code to a platform like GitHub.

The industry standard is to use a **`.env` file** to store your "secrets" and keep them out of your source code.

---

## 1. Install the Library

First, install `python-dotenv`. This library allows Django to read key-value pairs from a simple text file and treat them as environment variables.

```bash
pip install python-dotenv

```

---

## 2. Create the `.env` File

In your project's root directory (the same place where `manage.py` lives), create a new file named exactly `.env`. **Do not add this file to Git.**

```text
# .env file
DEBUG=False
SECRET_KEY=your-django-secret-key
DB_NAME=production_db
DB_USER=admin_user
DB_PASSWORD=super-secret-password-123
DB_HOST=127.0.0.1
DB_PORT=5432

```

---

## 3. Configure `settings.py`

Now, update your `settings.py` to pull these values from the environment instead of being hardcoded strings.

```python
import os
from pathlib import Path
from dotenv import load_dotenv

# Load the .env file
load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent

# Pull values using os.getenv(KEY, DEFAULT)
SECRET_KEY = os.getenv('SECRET_KEY')
DEBUG = os.getenv('DEBUG') == 'True'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.getenv('DB_NAME'),
        'USER': os.getenv('DB_USER'),
        'PASSWORD': os.getenv('DB_PASSWORD'),
        'HOST': os.getenv('DB_HOST'),
        'PORT': os.getenv('DB_PORT'),
    }
}

```

---

## 4. The "Safety Net" (`.gitignore`)

This is the most critical step. You must tell Git to ignore your `.env` file so it never leaves your computer. Open (or create) a file named `.gitignore` in your root folder and add this line:

```text
.env

```

---

## 5. Why This Setup Wins

* **Security:** Your database password stays on your server and your laptop, never in your code repository.
* **Environment Parity:** You can have a `.env` file on your laptop with your local DB settings and a different `.env` file on your production server with the real production DB settings. The code in `settings.py` stays exactly the same for both.
* **Compliance:** Many modern hosting platforms (like Heroku, AWS, or DigitalOcean) prefer this method for managing configurations.

### Pro-Tip: `.env.example`

Since you aren't committing your `.env` file, your teammates won't know which variables they need to set up. Itâ€™s best practice to create a file called `.env.example` that contains the keys but **none of the real secrets**.

```text
# .env.example
DB_NAME=
DB_USER=
DB_PASSWORD=

```
